=== src/camera/FlightController.ts ===
import * as THREE from 'three';
import type { CameraConfig } from '../types';
import { InputManager } from '../core/InputManager';
import { TerrainManager } from '../terrain/TerrainManager';

/**
 * Flight controller responsible for:
 * - Free-flight 5DOF camera controls (no roll)
 * - Smooth acceleration/deceleration
 * - Speed adjustment via scroll wheel
 * - Camera movement based on input
 * - Terrain collision prevention
 */
export class FlightController {
  private camera: THREE.PerspectiveCamera;
  private inputManager: InputManager;
  private config: CameraConfig;
  private terrainManager: TerrainManager | null = null;
  
  // Current velocity in world space
  private velocity: THREE.Vector3 = new THREE.Vector3();
  
  // Current speed multiplier (adjusted by scroll wheel)
  private speedMultiplier: number = 1.0;
  
  // Shift key speed boost multiplier
  private readonly shiftSpeedMultiplier: number = 3.0;
  
  // Euler angles for rotation (pitch, yaw only - no roll)
  private pitch: number = 0; // Up/down rotation
  private yaw: number = 0;   // Left/right rotation
  
  // Reusable vectors to avoid per-frame allocations
  private readonly moveDirection: THREE.Vector3 = new THREE.Vector3();
  private readonly forward: THREE.Vector3 = new THREE.Vector3();
  private readonly right: THREE.Vector3 = new THREE.Vector3();
  private readonly up: THREE.Vector3 = new THREE.Vector3(0, 1, 0);
  private readonly targetPosition: THREE.Vector3 = new THREE.Vector3();

  constructor(
    camera: THREE.PerspectiveCamera, 
    inputManager: InputManager, 
    config: CameraConfig,
    terrainManager?: TerrainManager
  ) {
    this.camera = camera;
    this.inputManager = inputManager;
    this.config = config;
    this.terrainManager = terrainManager ?? null;
    
    // Initialize rotation from camera's current orientation
    const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
    this.yaw = euler.y;
    this.pitch = euler.x;
  }

  /**
   * Update camera position and rotation based on input
   */
  update(deltaTime: number): void {
    this.handleMouseLook();
    this.handleSpeedAdjustment();
    this.handleMovement(deltaTime);
    this.applyTransform();
  }

  /**
   * Handle mouse look (pitch and yaw)
   */
  private handleMouseLook(): void {
    if (!this.inputManager.isPointerLockActive()) return;

    const mouseDelta = this.inputManager.getMouseDelta();
    
    // Apply mouse sensitivity
    this.yaw -= mouseDelta.x * this.config.mouseSensitivity;
    this.pitch -= mouseDelta.y * this.config.mouseSensitivity;
    
    // Clamp pitch to prevent flipping (slightly less than 90 degrees)
    const maxPitch = Math.PI / 2 - 0.01;
    this.pitch = Math.max(-maxPitch, Math.min(maxPitch, this.pitch));
  }

  /**
   * Handle scroll wheel speed adjustment
   */
  private handleSpeedAdjustment(): void {
    const scrollDelta = this.inputManager.getScrollDelta();
    
    if (scrollDelta !== 0) {
      // Scroll down increases speed, scroll up decreases
      const scrollFactor = 1.0 - scrollDelta * 0.001;
      this.speedMultiplier *= scrollFactor;
      
      // Clamp to min/max speed range
      const minMultiplier = this.config.minSpeed / this.config.baseSpeed;
      const maxMultiplier = this.config.maxSpeed / this.config.baseSpeed;
      this.speedMultiplier = Math.max(minMultiplier, Math.min(maxMultiplier, this.speedMultiplier));
    }
  }

  /**
   * Handle keyboard movement input
   */
  private handleMovement(deltaTime: number): void {
    // Calculate forward and right vectors from yaw only (ignore pitch for movement)
    this.forward.set(
      -Math.sin(this.yaw),
      0,
      -Math.cos(this.yaw)
    ).normalize();
    
    this.right.set(
      Math.cos(this.yaw),
      0,
      -Math.sin(this.yaw)
    ).normalize();

    // Build movement direction from input
    this.moveDirection.set(0, 0, 0);

    // Forward/backward (W/S)
    if (this.inputManager.isKeyPressed('w')) {
      this.moveDirection.add(this.forward);
    }
    if (this.inputManager.isKeyPressed('s')) {
      this.moveDirection.sub(this.forward);
    }

    // Strafe left/right (A/D)
    if (this.inputManager.isKeyPressed('a')) {
      this.moveDirection.sub(this.right);
    }
    if (this.inputManager.isKeyPressed('d')) {
      this.moveDirection.add(this.right);
    }

    // Up/down (E for up, Q for down)
    if (this.inputManager.isKeyPressed('e')) {
      this.moveDirection.add(this.up);
    }
    if (this.inputManager.isKeyPressed('q')) {
      this.moveDirection.sub(this.up);
    }

    // Normalize if moving diagonally
    if (this.moveDirection.lengthSq() > 0) {
      this.moveDirection.normalize();
    }

    // Calculate target velocity with shift speed boost
    const shiftBoost = this.inputManager.isKeyPressed('shift') ? this.shiftSpeedMultiplier : 1.0;
    const baseTargetSpeed = this.config.baseSpeed * this.speedMultiplier * shiftBoost;

    // Apply speed scaling based on Altitude Above Ground Level (AGL)
    // ONLY applied to the vertical (Y) component of movement AND only when moving DOWN
    let ySpeedFactor = 1.0;
    if (this.terrainManager && this.moveDirection.y < 0) {
      const terrainHeight = this.terrainManager.getHeightAt(this.camera.position.x, this.camera.position.z);
      if (terrainHeight !== null) {
        const altitudeAGL = this.camera.position.y - terrainHeight;
        
        // Custom smooth slowdown curve:
        // 50m -> 5m: 100% -> 50%
        // 5m -> 1m: 50% -> 25%
        // 1m -> 0.5m: 25% -> 0%
        if (altitudeAGL <= 0.5) {
          ySpeedFactor = 0.0;
        } else if (altitudeAGL <= 1.0) {
          // 1.0m to 0.5m: maps 25% to 0%
          const t = (altitudeAGL - 0.5) / (1.0 - 0.5);
          ySpeedFactor = THREE.MathUtils.lerp(0.0, 0.25, t);
        } else if (altitudeAGL <= 5.0) {
          // 5.0m to 1.0m: maps 50% to 25%
          const t = (altitudeAGL - 1.0) / (5.0 - 1.0);
          ySpeedFactor = THREE.MathUtils.lerp(0.25, 0.5, t);
        } else if (altitudeAGL <= 50.0) {
          // 50m to 5.0m: maps 100% to 50%
          const t = (altitudeAGL - 5.0) / (50.0 - 5.0);
          ySpeedFactor = THREE.MathUtils.lerp(0.5, 1.0, t);
        }
      }
    }

    // Split movement into horizontal and vertical components to apply scaling separately
    const targetVelocity = new THREE.Vector3();
    
    // Horizontal component (X, Z) - remains at base speed
    targetVelocity.x = this.moveDirection.x * baseTargetSpeed;
    targetVelocity.z = this.moveDirection.z * baseTargetSpeed;
    
    // Vertical component (Y) - scaled by ySpeedFactor
    targetVelocity.y = this.moveDirection.y * baseTargetSpeed * ySpeedFactor;

    // Smooth acceleration/deceleration using exponential decay
    const smoothing = 1.0 - Math.exp(-this.config.acceleration * deltaTime);
    this.velocity.lerp(targetVelocity, smoothing);

    // Predict next position
    this.targetPosition.copy(this.camera.position);
    this.targetPosition.addScaledVector(this.velocity, deltaTime);

    // Prevent collision with terrain
    if (this.terrainManager) {
      // 1. Ensure current altitude is respected (prevents sinking if terrain loads under us)
      const currentTerrainHeight = this.terrainManager.getHeightAt(this.camera.position.x, this.camera.position.z);
      if (currentTerrainHeight !== null) {
        const minHeight = currentTerrainHeight + this.config.minAltitudeAGL;
        if (this.camera.position.y < minHeight) {
          this.camera.position.y = minHeight;
          // Sync targetPosition if we were forced up
          this.targetPosition.y = Math.max(this.targetPosition.y, minHeight);
        }
      }

      // 2. Check target position for future collision
      const targetTerrainHeight = this.terrainManager.getHeightAt(this.targetPosition.x, this.targetPosition.z);
      if (targetTerrainHeight !== null) {
        const minHeight = targetTerrainHeight + this.config.minAltitudeAGL;
        if (this.targetPosition.y < minHeight) {
          this.targetPosition.y = minHeight;
          
          // Zero out downward velocity component if we hit the floor
          if (this.velocity.y < 0) {
            this.velocity.y = 0;
          }
        }
      }
    }

    // Apply position
    this.camera.position.copy(this.targetPosition);
  }

  /**
   * Apply rotation transform to camera
   */
  private applyTransform(): void {
    // Apply rotation using YXZ order (yaw, pitch, roll)
    // This prevents gimbal lock and gives intuitive FPS-style controls
    this.camera.quaternion.setFromEuler(
      new THREE.Euler(this.pitch, this.yaw, 0, 'YXZ')
    );
  }

  /**
   * Get current speed in m/s
   */
  getCurrentSpeed(): number {
    return this.velocity.length();
  }

  /**
   * Get current altitude (Y position)
   */
  getAltitude(): number {
    return this.camera.position.y;
  }

  /**
   * Get current speed multiplier
   */
  getSpeedMultiplier(): number {
    return this.speedMultiplier;
  }
}

=== src/core/Engine.ts ===
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
import { FlightController } from '../camera/FlightController';
import { TerrainManager } from '../terrain/TerrainManager';
import { CelestialSystem } from '../environment/CelestialSystem';
import { InputManager } from './InputManager';

/**
 * Main engine class responsible for:
 * - Renderer setup and initialization
 * - Main render loop with deltaTime tracking
 * - Scene management
 * - FlightController updates
 * - TerrainManager updates
 * - Stats display (FPS, draw calls, triangles)
 */
export class Engine {
  private renderer: THREE.WebGLRenderer;
  private scene: THREE.Scene;
  private camera: THREE.PerspectiveCamera;
  private animationId: number | null = null;
  private flightController: FlightController | null = null;
  private terrainManager: TerrainManager | null = null;
  private celestialSystem: CelestialSystem | null = null;
  private inputManager: InputManager | null = null;
  
  // Post-processing
  private composer: EffectComposer;
  private bloomPass: UnrealBloomPass;
  
  // Time tracking
  private clock: THREE.Clock = new THREE.Clock();
  private lastTime: number = 0;
  private deltaTime: number = 0;
  
  // Stats display
  private statsElement: HTMLDivElement | null = null;
  private frameCount: number = 0;
  private fpsUpdateTime: number = 0;
  private currentFPS: number = 0;
  private lastTriangleCount: number = 0;

  constructor(canvas: HTMLCanvasElement) {
    // Initialize renderer
    this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 1.0;

    // Initialize scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x000000);

    // Initialize camera
    this.camera = new THREE.PerspectiveCamera(
      70,
      window.innerWidth / window.innerHeight,
      0.1,
      100000
    );
    this.camera.position.set(0, 100, 200);

    // Initialize post-processing
    this.composer = new EffectComposer(this.renderer);
    
    // Render pass - renders the scene
    const renderPass = new RenderPass(this.scene, this.camera);
    this.composer.addPass(renderPass);
    
    // Bloom pass - creates glow effect on bright objects
    const resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
    this.bloomPass = new UnrealBloomPass(
      resolution,
      0.5,   // strength - intensity of bloom
      0.4,   // radius - spread of bloom
      0.85   // threshold - brightness cutoff for bloom
    );
    this.composer.addPass(this.bloomPass);
    
    // Output pass - applies tone mapping and color space conversion
    const outputPass = new OutputPass();
    this.composer.addPass(outputPass);

    // Handle window resize
    window.addEventListener('resize', () => this.handleResize());
    
    // Create stats display
    this.createStatsDisplay();
  }

  /**
   * Create the stats overlay UI
   */
  private createStatsDisplay(): void {
    this.statsElement = document.createElement('div');
    this.statsElement.id = 'stats-display';
    this.statsElement.style.cssText = `
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: #0f0;
      font-family: 'Monaco', 'Consolas', monospace;
      font-size: 12px;
      padding: 10px;
      border-radius: 4px;
      z-index: 1000;
      pointer-events: none;
      line-height: 1.5;
    `;
    document.body.appendChild(this.statsElement);
  }

  /**
   * Update the stats display
   */
  private updateStatsDisplay(deltaTime: number): void {
    if (!this.statsElement) return;
    
    // Update FPS counter (every 500ms)
    this.frameCount++;
    this.fpsUpdateTime += deltaTime;
    if (this.fpsUpdateTime >= 0.5) {
      this.currentFPS = Math.round(this.frameCount / this.fpsUpdateTime);
      this.frameCount = 0;
      this.fpsUpdateTime = 0;
    }
    
    const chunks = this.terrainManager?.getActiveChunkCount() ?? 0;
    const buildQueue = this.terrainManager?.getBuildQueueLength() ?? 0;
    
    const cameraPos = this.camera.position;
    const terrainHeight = this.terrainManager?.getHeightAt(cameraPos.x, cameraPos.z) ?? null;
    const agl = terrainHeight !== null ? (cameraPos.y - terrainHeight).toFixed(2) : 'N/A';
    const terrainH = terrainHeight !== null ? terrainHeight.toFixed(2) : 'N/A';
    
    // Curvature debug info
    const planetRadius = this.celestialSystem?.getPlanetRadius() ?? 5000;
    const d = Math.sqrt(cameraPos.x * cameraPos.x + cameraPos.z * cameraPos.z);
    const theta = d / planetRadius;
    const thetaDeg = (theta * 180 / Math.PI).toFixed(1);
    const phi = Math.atan2(cameraPos.z, cameraPos.x);
    const phiDeg = (phi * 180 / Math.PI).toFixed(1);
    
    this.statsElement.innerHTML = `
      <strong>Camera Position</strong><br>
      X: ${cameraPos.x.toFixed(1)}m<br>
      Y: ${cameraPos.y.toFixed(1)}m<br>
      Z: ${cameraPos.z.toFixed(1)}m<br>
      <br>
      <strong>Curvature</strong><br>
      Distance: ${d.toFixed(1)}m<br>
      θ (tilt): ${thetaDeg}°<br>
      φ (dir): ${phiDeg}°<br>
      Radius: ${planetRadius}m<br>
      <br>
      <strong>Render</strong><br>
      FPS: ${this.currentFPS}<br>
      Triangles: ${this.lastTriangleCount.toLocaleString()}<br>
      <br>
      <strong>Terrain</strong><br>
      Chunks: ${chunks} (queue: ${buildQueue})<br>
      Terrain Y: ${terrainH}m<br>
      AGL: ${agl}m
    `;
  }

  /**
   * Set the flight controller for camera updates
   */
  setFlightController(controller: FlightController): void {
    this.flightController = controller;
  }

  /**
   * Set the terrain manager for terrain updates
   */
  setTerrainManager(manager: TerrainManager): void {
    this.terrainManager = manager;
  }

  /**
   * Set the celestial system for sun/Earth updates
   */
  setCelestialSystem(system: CelestialSystem): void {
    this.celestialSystem = system;
  }

  /**
   * Set the input manager for input handling
   */
  setInputManager(manager: InputManager): void {
    this.inputManager = manager;
  }

  /**
   * Get the Three.js scene
   */
  getScene(): THREE.Scene {
    return this.scene;
  }

  /**
   * Get the camera
   */
  getCamera(): THREE.PerspectiveCamera {
    return this.camera;
  }

  /**
   * Get the renderer
   */
  getRenderer(): THREE.WebGLRenderer {
    return this.renderer;
  }

  /**
   * Start the render loop
   */
  start(): void {
    this.clock.start();
    this.lastTime = this.clock.getElapsedTime();
    
    const animate = () => {
      this.animationId = requestAnimationFrame(animate);
      
      // Calculate delta time
      const currentTime = this.clock.getElapsedTime();
      const deltaTime = currentTime - this.lastTime;
      this.lastTime = currentTime;
      
      this.update(deltaTime);
      this.render();
    };
    animate();
  }

  /**
   * Stop the render loop
   */
  stop(): void {
    if (this.animationId !== null) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
  }

  /**
   * Update loop (called every frame)
   */
  private update(deltaTime: number): void {
    this.deltaTime = deltaTime;
    
    // Check for debug toggle (O key)
    if (this.inputManager?.isKeyJustPressed('o') && this.terrainManager) {
      this.terrainManager.toggleDebugMode();
    }

    // Check for chunk distance/LOD debug (I key)
    if (this.inputManager?.isKeyJustPressed('i') && this.terrainManager) {
      this.terrainManager.logChunkDistancesAndLods(this.camera.position);
    }

    // Check for camera position debug (C key)
    if (this.inputManager?.isKeyJustPressed('c')) {
      const pos = this.camera.position;
      const rot = this.camera.rotation;
      console.log(`Camera Position: x=${pos.x.toFixed(2)}, y=${pos.y.toFixed(2)}, z=${pos.z.toFixed(2)}`);
      console.log(`Camera Rotation: x=${rot.x.toFixed(4)}, y=${rot.y.toFixed(4)}, z=${rot.z.toFixed(4)}`);
    }

    // Update flight controller
    if (this.flightController) {
      this.flightController.update(deltaTime);
    }

    // Update terrain manager with camera position
    if (this.terrainManager) {
      this.terrainManager.update(this.camera.position);
    }

    // Update celestial system (sun, Earth, curvature)
    if (this.celestialSystem) {
      this.celestialSystem.update(this.camera.position, deltaTime);
    }

    // Update input manager (clear just-pressed keys)
    if (this.inputManager) {
      this.inputManager.update();
    }
    
    // Update stats display
    this.updateStatsDisplay(deltaTime);
  }

  /**
   * Render loop (called every frame)
   */
  private render(): void {
    // Use post-processing composer instead of direct rendering
    this.composer.render(this.deltaTime);
    
    // Read triangle count after rendering (renderer.info is populated during render)
    // In wireframe mode, Three.js counts lines instead of triangles.
    // We add render.lines / 3 to account for triangles rendered as wireframes.
    this.lastTriangleCount = Math.round(this.renderer.info.render.triangles + this.renderer.info.render.lines / 3);
  }

  /**
   * Handle window resize
   */
  private handleResize(): void {
    const width = window.innerWidth;
    const height = window.innerHeight;
    
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(width, height);
    this.composer.setSize(width, height);
    
    // Update bloom pass resolution
    this.bloomPass.resolution.set(width, height);
  }

  /**
   * Cleanup resources
   */
  dispose(): void {
    this.stop();
    if (this.terrainManager) {
      this.terrainManager.dispose();
    }
    if (this.celestialSystem) {
      this.celestialSystem.dispose();
    }
    if (this.statsElement) {
      this.statsElement.remove();
    }
    this.composer.dispose();
    this.renderer.dispose();
  }
}

=== src/core/InputManager.ts ===
/**
 * Input manager responsible for:
 * - Keyboard input handling
 * - Mouse input handling
 * - Pointer lock management
 * - Input state tracking
 * - Scroll wheel for speed adjustment
 */
export class InputManager {
  private keys: Set<string> = new Set();
  private keysJustPressed: Set<string> = new Set();
  private mouseDelta: { x: number; y: number } = { x: 0, y: 0 };
  private scrollDelta: number = 0;
  private isPointerLocked: boolean = false;

  constructor() {
    this.setupEventListeners();
  }

  /**
   * Set up keyboard and mouse event listeners
   */
  private setupEventListeners(): void {
    window.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      // Track just-pressed keys (not already held)
      if (!this.keys.has(key)) {
        this.keysJustPressed.add(key);
      }
      this.keys.add(key);
    });

    window.addEventListener('keyup', (e) => {
      this.keys.delete(e.key.toLowerCase());
    });

    document.addEventListener('mousemove', (e) => {
      if (this.isPointerLocked) {
        this.mouseDelta.x += e.movementX;
        this.mouseDelta.y += e.movementY;
      }
    });

    document.addEventListener('pointerlockchange', () => {
      this.isPointerLocked = document.pointerLockElement !== null;
    });

    // Scroll wheel for speed adjustment
    window.addEventListener('wheel', (e) => {
      this.scrollDelta += e.deltaY;
    });
  }

  /**
   * Check if a key is currently pressed
   */
  isKeyPressed(key: string): boolean {
    return this.keys.has(key.toLowerCase());
  }

  /**
   * Check if a key was just pressed this frame
   * Call update() at the end of each frame to clear just-pressed state
   */
  isKeyJustPressed(key: string): boolean {
    return this.keysJustPressed.has(key.toLowerCase());
  }

  /**
   * Update input state (call at end of frame to clear just-pressed keys)
   */
  update(): void {
    this.keysJustPressed.clear();
  }

  /**
   * Get mouse delta movement (since last call)
   */
  getMouseDelta(): { x: number; y: number } {
    const delta = { ...this.mouseDelta };
    this.mouseDelta = { x: 0, y: 0 };
    return delta;
  }

  /**
   * Get scroll wheel delta (since last call)
   * Positive = scroll down, Negative = scroll up
   */
  getScrollDelta(): number {
    const delta = this.scrollDelta;
    this.scrollDelta = 0;
    return delta;
  }

  /**
   * Check if pointer is locked
   */
  isPointerLockActive(): boolean {
    return this.isPointerLocked;
  }

  /**
   * Request pointer lock
   */
  requestPointerLock(): void {
    document.body.requestPointerLock();
  }

  /**
   * Cleanup event listeners
   */
  dispose(): void {
    // Event listeners will be cleaned up automatically
  }
}

=== src/environment/CelestialSystem.ts ===
import * as THREE from 'three';
import { EarthMaterial } from '../shaders/EarthMaterial';
import { SunMaterial } from '../shaders/SunMaterial';

/**
 * CelestialSystem manages the sun, Earth, starfield, and directional lighting
 * with Moon curvature simulation.
 * 
 * Key features:
 * - Sun: Glowing sphere that drives directional light
 * - Earth: Realistic day/night cycle based on sun direction
 * - Curvature: As player moves, the entire sky (sun, Earth, stars) rotates
 *              to simulate traveling on a curved planetary surface
 * 
 * LIGHTING ARCHITECTURE:
 * Three light sources, all respecting curvature rotation:
 * 1. Sun Light (DirectionalLight): Main light from sun's world position
 * 2. Earth Light (DirectionalLight): Weak bluish earthshine from Earth's world position
 * 3. Spaceship Light (PointLight): Local illumination attached to camera
 * 
 * IMPORTANT: Sun and Earth lights use getWorldPosition() to get positions
 * AFTER curvature rotation is applied to the celestialContainer. This ensures
 * lighting direction matches the visual positions of celestial objects.
 * 
 * The curvature uses the same formula as the terrain shader:
 * - θ (theta) = distance / planetRadius (rotation angle)
 * - φ (phi) = atan2(z, x) (direction of travel)
 * 
 * Flying a full circumference (2πR) brings the sky back to its original position.
 */

export interface CelestialConfig {
  // Sun configuration
  sunDistance?: number;      // Distance from camera (visual only)
  sunSize?: number;          // Visual size of sun sphere
  sunIntensity?: number;     // Light intensity
  
  // Earth configuration
  earthDistance?: number;    // Distance from camera (visual only)
  earthSize?: number;        // Visual size of Earth sphere
  
  // Earthshine (reflected light from Earth)
  earthshineMultiplier?: number;  // Multiplier of sun intensity (0-1)
  
  // Spaceship light (local illumination)
  spaceshipLightIntensity?: number;
  spaceshipLightRange?: number;   // Range in meters
  
  // Flashlight (directional cone pointing where camera looks)
  flashlightIntensity?: number;
  flashlightRange?: number;       // Range in meters
  flashlightAngle?: number;       // Cone angle in radians
  flashlightPenumbra?: number;    // Edge softness (0-1)
  
  // Initial positions (angles in radians)
  // Measured from the reference "up" at origin
  sunAzimuth?: number;       // Horizontal angle
  sunElevation?: number;     // Vertical angle above horizon
  earthAzimuth?: number;
  earthElevation?: number;
}

const DEFAULT_CONFIG: Required<CelestialConfig> = {
  sunDistance: 50000,    // Far enough to look like skybox object
  sunSize: 500,          // Visual size
  sunIntensity: 5.0,
  earthDistance: 40000,
  earthSize: 1500,       // Earth appears ~4x larger than sun from Moon
  earthshineMultiplier: 0.15,
  spaceshipLightIntensity: 5,     // Default intensity
  spaceshipLightRange: 200,        // 200m range
  flashlightIntensity: 10,         // Default intensity
  flashlightRange: 500,            // 500m range
  flashlightAngle: Math.PI / 8,    // ~22.5 degree cone
  flashlightPenumbra: 0.3,         // Soft edges
  sunAzimuth: Math.PI * 0.25,      // 45 degrees from north
  sunElevation: Math.PI * 0.35,    // 63 degrees above horizon
  earthAzimuth: Math.PI * 1.2,     // Opposite-ish from sun
  earthElevation: Math.PI * 0.3,   // 54 degrees above horizon
};

export class CelestialSystem {
  private scene: THREE.Scene;
  private config: Required<CelestialConfig>;
  
  // Planet radius for curvature (synced with terrain shader)
  private planetRadius: number = 5000; // Default matches MoonMaterial default
  
  // Celestial objects
  private sunMesh!: THREE.Mesh;
  private sunMaterial!: SunMaterial;
  private earthMesh!: THREE.Mesh;
  private earthMaterial!: EarthMaterial;
  
  // Lighting - four sources
  private sunLight!: THREE.DirectionalLight;      // Main directional light from sun
  private earthLight!: THREE.DirectionalLight;    // Weak bluish earthshine
  private spaceshipLight!: THREE.PointLight;      // Local illumination on camera
  private flashlight!: THREE.SpotLight;           // Directional cone pointing where camera looks
  private flashlightTarget: THREE.Object3D;       // Target for flashlight direction
  
  // Camera reference for spaceship light positioning
  private camera: THREE.Camera | null = null;
  
  // Container that rotates with curvature
  private celestialContainer: THREE.Group;
  
  // Base skybox rotation (set by Skybox class - Milky Way overhead)
  private readonly baseSkyboxRotation = new THREE.Euler(Math.PI / 2, 0, 0);
  private readonly baseSkyboxQuaternion = new THREE.Quaternion();
  
  // Reusable objects for calculations (avoid per-frame allocations)
  private readonly sunDirection = new THREE.Vector3();
  private readonly curvatureQuaternion = new THREE.Quaternion();
  private readonly rotationAxis = new THREE.Vector3();
  
  // Reusable vectors for world position calculations
  private readonly sunWorldPos = new THREE.Vector3();
  private readonly earthWorldPos = new THREE.Vector3();
  
  constructor(scene: THREE.Scene, config: CelestialConfig = {}) {
    this.scene = scene;
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.celestialContainer = new THREE.Group();
    this.celestialContainer.name = 'CelestialSystem';
    
    // Create flashlight target (SpotLight needs a target to point at)
    this.flashlightTarget = new THREE.Object3D();
    this.flashlightTarget.name = 'FlashlightTarget';
    
    // Store base skybox rotation as quaternion for composition
    this.baseSkyboxQuaternion.setFromEuler(this.baseSkyboxRotation);
    
    this.initializeSun();
    this.initializeEarth();
    this.initializeLighting();
    
    this.scene.add(this.celestialContainer);
    
    // Initial update to position everything
    this.updateSunDirection();
  }
  
  /**
   * Set camera reference for spaceship light positioning
   */
  setCamera(camera: THREE.Camera): void {
    this.camera = camera;
  }
  
  /**
   * Create the sun mesh
   */
  private initializeSun(): void {
    const geometry = new THREE.SphereGeometry(this.config.sunSize, 32, 32);
    this.sunMaterial = new SunMaterial({
      color: 0xffffee,
      intensity: 3.0,
    });
    
    this.sunMesh = new THREE.Mesh(geometry, this.sunMaterial);
    this.sunMesh.name = 'Sun';
    
    // Position sun based on azimuth and elevation
    this.positionCelestialBody(
      this.sunMesh,
      this.config.sunAzimuth,
      this.config.sunElevation,
      this.config.sunDistance
    );
    
    // Put sun on bloom layer
    this.sunMesh.layers.enable(1);
    
    this.celestialContainer.add(this.sunMesh);
  }
  
  /**
   * Create the Earth mesh with realistic shader
   */
  private initializeEarth(): void {
    const geometry = new THREE.SphereGeometry(this.config.earthSize, 64, 64);
    this.earthMaterial = new EarthMaterial({
      dayMapPath: '/textures/8k_earth_daymap.jpg',
      nightMapPath: '/textures/8k_earth_nightmap.jpg',
      cloudsMapPath: '/textures/8k_earth_clouds.jpg',
      specularMapPath: '/textures/8k_earth_specular_map.jpg',
    });
    
    this.earthMesh = new THREE.Mesh(geometry, this.earthMaterial);
    this.earthMesh.name = 'Earth';
    
    // Position Earth based on azimuth and elevation
    this.positionCelestialBody(
      this.earthMesh,
      this.config.earthAzimuth,
      this.config.earthElevation,
      this.config.earthDistance
    );
    
    // Tilt Earth's axis (23.5 degrees)
    this.earthMesh.rotation.z = THREE.MathUtils.degToRad(23.5);
    
    this.celestialContainer.add(this.earthMesh);
  }
  
  /**
   * Initialize the three light sources:
   * 1. Sun Light - main directional light from sun's world position
   * 2. Earth Light - weak bluish earthshine from Earth's world position
   * 3. Spaceship Light - point light attached to camera
   * 
   * IMPORTANT: Sun and Earth light positions are updated each frame using
   * getWorldPosition() AFTER curvature rotation. This ensures light direction
   * matches the visual position of celestial objects in the sky.
   */
  private initializeLighting(): void {
    // 1. Main directional light from sun
    this.sunLight = new THREE.DirectionalLight(0xffffff, this.config.sunIntensity);
    this.sunLight.name = 'SunLight';
    
    // Shadow configuration for sun
    this.sunLight.castShadow = true;
    this.sunLight.shadow.mapSize.width = 2048;
    this.sunLight.shadow.mapSize.height = 2048;
    this.sunLight.shadow.camera.near = 0.5;
    this.sunLight.shadow.camera.far = 5000;
    this.sunLight.shadow.camera.left = -2000;
    this.sunLight.shadow.camera.right = 2000;
    this.sunLight.shadow.camera.top = 2000;
    this.sunLight.shadow.camera.bottom = -2000;
    
    // Light is positioned at scene root (not in container)
    // Position will be updated each frame from sun's world position
    this.scene.add(this.sunLight);
    
    // 2. Earthshine - weak reflected light from Earth
    // Bluish tint, much weaker than sunlight
    const earthshineIntensity = this.config.sunIntensity * this.config.earthshineMultiplier;
    this.earthLight = new THREE.DirectionalLight(0x8899ff, earthshineIntensity);
    this.earthLight.name = 'EarthLight';
    // Position will be updated each frame from Earth's world position
    this.scene.add(this.earthLight);
    
    // 3. Spaceship light - local point light attached to camera
    this.spaceshipLight = new THREE.PointLight(
      0xffffff,
      this.config.spaceshipLightIntensity,
      this.config.spaceshipLightRange,
      2 // Quadratic decay for realistic falloff
    );
    this.spaceshipLight.name = 'SpaceshipLight';
    // Position will be updated each frame to match camera
    this.scene.add(this.spaceshipLight);
    
    // 4. Flashlight - SpotLight that points where camera looks
    this.flashlight = new THREE.SpotLight(
      0xffffff,
      this.config.flashlightIntensity,
      this.config.flashlightRange,
      this.config.flashlightAngle,
      this.config.flashlightPenumbra,
      2 // Quadratic decay
    );
    this.flashlight.name = 'Flashlight';
    this.flashlight.target = this.flashlightTarget;
    // Position and target will be updated each frame based on camera
    this.scene.add(this.flashlight);
    this.scene.add(this.flashlightTarget);
  }
  
  /**
   * Position a celestial body using spherical coordinates
   */
  private positionCelestialBody(
    mesh: THREE.Mesh,
    azimuth: number,
    elevation: number,
    distance: number
  ): void {
    // Convert spherical to cartesian
    // Azimuth is rotation around Y axis
    // Elevation is angle above XZ plane
    const cosElevation = Math.cos(elevation);
    mesh.position.set(
      Math.sin(azimuth) * cosElevation * distance,
      Math.sin(elevation) * distance,
      Math.cos(azimuth) * cosElevation * distance
    );
  }
  
  /**
   * Calculate curvature rotation based on camera position
   * Uses the same formula as terrain shader: θ = d / R
   * 
   * @param cameraPosition Camera world position
   */
  private calculateCurvatureRotation(cameraPosition: THREE.Vector3): void {
    const x = cameraPosition.x;
    const z = cameraPosition.z;
    
    // Horizontal distance from origin
    const d = Math.sqrt(x * x + z * z);
    
    // Rotation angle (same formula as shader)
    // θ = d / R where R is planetRadius
    // At d = 2πR, θ = 2π (full circle, back to start)
    const theta = d / this.planetRadius;
    
    if (theta < 0.0001) {
      // At origin, no rotation needed
      this.curvatureQuaternion.identity();
      return;
    }
    
    // Direction of travel (azimuth angle)
    const phi = Math.atan2(z, x);
    
    // The rotation axis is perpendicular to the travel direction
    // If traveling in direction phi, we tilt around axis at phi + 90°
    // This axis lies in the XZ plane
    this.rotationAxis.set(-Math.sin(phi), 0, Math.cos(phi));
    
    // Create rotation: tilt by theta around the perpendicular axis
    this.curvatureQuaternion.setFromAxisAngle(this.rotationAxis, theta);
  }
  
  /**
   * Update sun direction uniform for Earth shader and light positions
   * 
   * CRITICAL: Uses getWorldPosition() to get positions AFTER curvature
   * rotation is applied to celestialContainer. This ensures:
   * - Earth shader receives correct sun direction for day/night cycle
   * - DirectionalLight comes FROM the visual sun position
   * - Earthshine comes FROM the visual Earth position
   */
  private updateSunDirection(): void {
    // Get positions in WORLD SPACE (after container rotation)
    // This is critical for correct lighting direction after curvature rotation
    this.sunMesh.getWorldPosition(this.sunWorldPos);
    this.earthMesh.getWorldPosition(this.earthWorldPos);
    
    // Calculate direction FROM Earth TO Sun (for Earth shader)
    // Earth's day/night depends on which side faces the sun
    this.sunDirection.copy(this.sunWorldPos).sub(this.earthWorldPos).normalize();
    
    // Update Earth material with world-space sun direction
    this.earthMaterial.setSunDirection(this.sunDirection);
    
    // Update sun directional light position
    // Light should come FROM the sun's world position
    this.sunLight.position.copy(this.sunWorldPos);
    
    // Update earth directional light position
    // Earthshine comes FROM Earth's world position
    this.earthLight.position.copy(this.earthWorldPos);
  }
  
  /**
   * Update the celestial system
   * Call this every frame with the camera position
   * 
   * @param cameraPosition Camera world position
   * @param deltaTime Time since last frame (seconds)
   */
  update(cameraPosition: THREE.Vector3, deltaTime: number = 0.016): void {
    // Calculate curvature rotation based on position
    this.calculateCurvatureRotation(cameraPosition);
    
    // Apply curvature rotation to celestial container
    this.celestialContainer.quaternion.copy(this.curvatureQuaternion);
    
    // Move container to follow camera (celestial objects are at "infinity")
    this.celestialContainer.position.copy(cameraPosition);
    
    // Apply curvature rotation to skybox (stars)
    // Compute Euler angles directly instead of quaternion composition
    // Base rotation: PI/2 around X (Milky Way overhead)
    // Curvature tilt: decompose into X and Z components based on travel direction (phi)
    const x = cameraPosition.x;
    const z = cameraPosition.z;
    const d = Math.sqrt(x * x + z * z);
    const theta = d / this.planetRadius;
    const phi = d > 0.001 ? Math.atan2(z, x) : 0;
    
    // Decompose tilt into X and Z rotations
    // Moving in +X (phi=0): tilt around Z axis
    // Moving in +Z (phi=90°): tilt around -X axis
    const tiltX = -theta * Math.sin(phi);
    const tiltZ = theta * Math.cos(phi);
    
    // Apply to background rotation (base X rotation + tilt components)
    // Note: This is an approximation that works for small-ish theta
    this.scene.backgroundRotation.set(
      Math.PI / 2 + tiltX,  // Base + X tilt
      0,                     // No Y rotation
      tiltZ                  // Z tilt
    );
    
    // Update sun direction for Earth lighting and directional light positions
    // Must be called AFTER curvature rotation is applied to container
    this.updateSunDirection();
    
    // Update spaceship light to follow camera
    if (this.camera) {
      this.spaceshipLight.position.copy(this.camera.position);
      
      // Update flashlight position and direction
      this.flashlight.position.copy(this.camera.position);
      // Get camera forward direction and place target 100m ahead
      const forward = new THREE.Vector3(0, 0, -1);
      forward.applyQuaternion(this.camera.quaternion);
      this.flashlightTarget.position.copy(this.camera.position).add(forward.multiplyScalar(100));
    }
    
    // Slowly rotate Earth (one rotation per ~24 hours scaled down)
    this.earthMesh.rotation.y += deltaTime * 0.01;
  }
  
  /**
   * Set the planet radius for curvature calculation
   * Should match the terrain shader's planetRadius
   * 
   * @param radius Planet radius in meters
   */
  setPlanetRadius(radius: number): void {
    this.planetRadius = radius;
  }
  
  /**
   * Get the current planet radius
   */
  getPlanetRadius(): number {
    return this.planetRadius;
  }
  
  // ============================================
  // Light intensity getters/setters for UI control
  // ============================================
  
  /**
   * Get sun light intensity
   */
  get sunIntensity(): number {
    return this.sunLight.intensity;
  }
  
  /**
   * Set sun light intensity
   */
  set sunIntensity(value: number) {
    this.sunLight.intensity = value;
    // Also update earthshine to maintain ratio
    this.earthLight.intensity = value * this.config.earthshineMultiplier;
  }
  
  /**
   * Get earthshine multiplier (relative to sun)
   */
  get earthshineMultiplier(): number {
    return this.config.earthshineMultiplier;
  }
  
  /**
   * Set earthshine multiplier (relative to sun)
   */
  set earthshineMultiplier(value: number) {
    this.config.earthshineMultiplier = value;
    this.earthLight.intensity = this.sunLight.intensity * value;
  }
  
  /**
   * Get spaceship light intensity
   */
  get spaceshipLightIntensity(): number {
    return this.spaceshipLight.intensity;
  }
  
  /**
   * Set spaceship light intensity
   */
  set spaceshipLightIntensity(value: number) {
    this.spaceshipLight.intensity = value;
  }
  
  /**
   * Get spaceship light range
   */
  get spaceshipLightRange(): number {
    return this.spaceshipLight.distance;
  }
  
  /**
   * Set spaceship light range
   */
  set spaceshipLightRange(value: number) {
    this.spaceshipLight.distance = value;
  }
  
  /**
   * Get flashlight intensity
   */
  get flashlightIntensity(): number {
    return this.flashlight.intensity;
  }
  
  /**
   * Set flashlight intensity
   */
  set flashlightIntensity(value: number) {
    this.flashlight.intensity = value;
  }
  
  /**
   * Get flashlight range
   */
  get flashlightRange(): number {
    return this.flashlight.distance;
  }
  
  /**
   * Set flashlight range
   */
  set flashlightRange(value: number) {
    this.flashlight.distance = value;
  }
  
  /**
   * Get flashlight angle (cone width in radians)
   */
  get flashlightAngle(): number {
    return this.flashlight.angle;
  }
  
  /**
   * Set flashlight angle (cone width in radians)
   */
  set flashlightAngle(value: number) {
    this.flashlight.angle = value;
  }
  
  /**
   * Get the sun mesh (for bloom layer configuration)
   */
  getSunMesh(): THREE.Mesh {
    return this.sunMesh;
  }
  
  /**
   * Get the Earth mesh
   */
  getEarthMesh(): THREE.Mesh {
    return this.earthMesh;
  }
  
  /**
   * Get the directional light (sun)
   */
  getSunLight(): THREE.DirectionalLight {
    return this.sunLight;
  }
  
  /**
   * Get the sun direction in world space
   */
  getSunDirection(): THREE.Vector3 {
    return this.sunDirection.clone();
  }
  
  /**
   * Set sun position using azimuth and elevation
   */
  setSunPosition(azimuth: number, elevation: number): void {
    this.config.sunAzimuth = azimuth;
    this.config.sunElevation = elevation;
    this.positionCelestialBody(
      this.sunMesh,
      azimuth,
      elevation,
      this.config.sunDistance
    );
    this.updateSunDirection();
  }
  
  /**
   * Set Earth position using azimuth and elevation
   */
  setEarthPosition(azimuth: number, elevation: number): void {
    this.config.earthAzimuth = azimuth;
    this.config.earthElevation = elevation;
    this.positionCelestialBody(
      this.earthMesh,
      azimuth,
      elevation,
      this.config.earthDistance
    );
  }
  
  /**
   * Dispose of all resources
   */
  dispose(): void {
    this.sunMesh.geometry.dispose();
    this.sunMaterial.dispose();
    this.earthMesh.geometry.dispose();
    this.earthMaterial.dispose();
    this.sunLight.dispose();
    this.earthLight.dispose();
    this.spaceshipLight.dispose();
    this.flashlight.dispose();
    this.scene.remove(this.celestialContainer);
    this.scene.remove(this.sunLight);
    this.scene.remove(this.earthLight);
    this.scene.remove(this.spaceshipLight);
    this.scene.remove(this.flashlight);
    this.scene.remove(this.flashlightTarget);
  }
}

=== src/environment/Lighting.ts ===
import * as THREE from 'three';

/**
 * Lighting system responsible for:
 * - Sun directional light
 * - Hard shadows (Moon has no atmosphere)
 * - Shadow map configuration
 * - Ambient light (earthshine)
 */
export class Lighting {
  private sunLight!: THREE.DirectionalLight;
  private scene: THREE.Scene;

  constructor(scene: THREE.Scene) {
    this.scene = scene;
    this.initialize();
  }

  /**
   * Initialize lighting setup
   */
  private initialize(): void {
    // Sun directional light
    this.sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
    this.sunLight.position.set(1000, 1000, 1000);
    this.sunLight.castShadow = true;
    
    // Shadow configuration
    this.sunLight.shadow.mapSize.width = 2048;
    this.sunLight.shadow.mapSize.height = 2048;
    this.sunLight.shadow.camera.near = 0.5;
    this.sunLight.shadow.camera.far = 5000;
    this.sunLight.shadow.camera.left = -2000;
    this.sunLight.shadow.camera.right = 2000;
    this.sunLight.shadow.camera.top = 2000;
    this.sunLight.shadow.camera.bottom = -2000;

    this.scene.add(this.sunLight);

    // Minimal ambient light (earthshine)
    const ambientLight = new THREE.AmbientLight(0x000000, 0.05);
    this.scene.add(ambientLight);
  }

  /**
   * Get the sun light
   */
  getSunLight(): THREE.DirectionalLight {
    return this.sunLight;
  }

  /**
   * Update lighting (for day/night cycle, etc.)
   */
  update(): void {
    // Implementation will be added in future tickets
  }

  /**
   * Dispose lighting resources
   */
  dispose(): void {
    this.scene.remove(this.sunLight);
    this.sunLight.dispose();
  }
}

=== src/environment/Skybox.ts ===
import * as THREE from 'three';

/**
 * Skybox responsible for:
 * - Starfield background using equirectangular texture
 * - Black space rendering as fallback
 */
export class Skybox {
  private scene: THREE.Scene;
  private texture: THREE.Texture | null = null;

  constructor(scene: THREE.Scene) {
    this.scene = scene;
    this.initialize();
  }

  /**
   * Initialize skybox with default black background
   * Call loadTexture() to load the starfield
   */
  private initialize(): void {
    // Set scene background to black (space) as fallback
    this.scene.background = new THREE.Color(0x000000);
  }

  /**
   * Load an equirectangular texture for the skybox
   * @param texturePath Path to the equirectangular image
   */
  loadTexture(texturePath: string): void {
    const loader = new THREE.TextureLoader();
    
    loader.load(
      texturePath,
      (texture) => {
        // Configure for equirectangular mapping
        texture.mapping = THREE.EquirectangularReflectionMapping;
        texture.colorSpace = THREE.SRGBColorSpace;
        
        // Set as scene background
        this.scene.background = texture;
        this.texture = texture;
        
        // Rotate skybox so Milky Way is overhead instead of on horizon
        // Rotate 90 degrees around X axis
        this.scene.backgroundRotation = new THREE.Euler(Math.PI / 2, 0, 0);
        
        console.log('Skybox texture loaded successfully');
      },
      undefined, // Progress callback (not needed)
      (error) => {
        console.error('Failed to load skybox texture:', error);
        // Keep black background as fallback
      }
    );
  }

  /**
   * Update skybox (for future animations, etc.)
   */
  update(): void {
    // No updates needed for static skybox
  }

  /**
   * Dispose skybox resources
   */
  dispose(): void {
    if (this.texture) {
      this.texture.dispose();
      this.texture = null;
    }
  }
}

=== src/main.ts ===
import './style.css';
import { Engine } from './core/Engine';
import { InputManager } from './core/InputManager';
import { FlightController } from './camera/FlightController';
import { Skybox } from './environment/Skybox';
import { CelestialSystem } from './environment/CelestialSystem';
import { TerrainManager, TerrainConfig } from './terrain/TerrainManager';
import { LodDetailLevel } from './terrain/LodUtils';
import { ShaderUIController } from './ui/ShaderUIController';
import type { CameraConfig } from './types';

/**
 * Main entry point for Lunar Explorer
 * Initializes the Three.js scene and starts the render loop
 */

// Get canvas element
const app = document.querySelector<HTMLDivElement>('#app')!;
const canvas = document.createElement('canvas');
app.appendChild(canvas);

// Initialize engine
const engine = new Engine(canvas);

// Initialize input manager
const inputManager = new InputManager();

// Camera configuration (from PRD section 9.2)
const cameraConfig: CameraConfig = {
  fov: 70,
  near: 0.1,
  far: 100000,
  baseSpeed: 50,        // 50 m/s default
  minSpeed: 1,          // 1 m/s minimum
  maxSpeed: 1000,       // 1000 m/s maximum
  acceleration: 5.0,    // Smoothing factor
  mouseSensitivity: 0.002,
  minAltitudeAGL: 0.5,    // Minimum altitude above ground (meters)
  slowdownAltitude: 50, // Start slowing at this AGL (meters)
  slowdownFactor: 0.0, // Speed multiplier at minimum altitude
};

// Terrain configuration
const terrainConfig: TerrainConfig = {
  renderDistance: 30,    // Chunks to load in each direction
  chunkWidth: 100,       // World units per chunk
  chunkDepth: 100,       // World units per chunk
  lodLevels: [1024, 512, 256, 128, 64, 32, 16, 8, 4], // Resolution levels (highest to lowest)
  lodDetailLevel: LodDetailLevel.Balanced,   // Target screen-space triangle size
  workerCount: 3,        // 1 high-priority + 2 normal workers
};

// Initialize terrain manager first (needed by flight controller)
const terrainManager = new TerrainManager(engine.getScene(), terrainConfig);
terrainManager.setCamera(engine.getCamera());
engine.setTerrainManager(terrainManager);

// Initialize flight controller with terrain manager
const flightController = new FlightController(
  engine.getCamera(),
  inputManager,
  cameraConfig,
  terrainManager
);
engine.setFlightController(flightController);

// Set input manager in engine
engine.setInputManager(inputManager);

// Set initial camera position above terrain
const initialX = -3;
const initialZ = 8;
const terrainHeight = terrainManager.getHeightAt(initialX, initialZ);
if (terrainHeight !== null) {
  engine.getCamera().position.set(initialX, terrainHeight + cameraConfig.minAltitudeAGL + 5, initialZ); // Start 5m above min altitude
} else {
  engine.getCamera().position.set(initialX, 4, initialZ); // Fallback height
}
engine.getCamera().rotation.x -= 0.4;
engine.getCamera().rotation.y -= 0.2;
engine.getCamera().rotation.z -= 0.06;

// Set up click to enable pointer lock
canvas.addEventListener('click', () => {
  inputManager.requestPointerLock();
});

// Initialize skybox with Milky Way texture
const skybox = new Skybox(engine.getScene());
skybox.loadTexture('/textures/8k_stars_milky_way.jpg');

// Initialize celestial system (sun, Earth, lighting with Moon curvature)
// Only override position values - all intensity/range defaults come from CelestialSystem
const celestialSystem = new CelestialSystem(engine.getScene(), {
  // Sun position - high in the sky, slightly to the side
  sunAzimuth: Math.PI * 0.3,
  sunElevation: Math.PI * 0.35,
  
  // Earth position - visible in the lunar sky
  earthAzimuth: Math.PI * 1.15,
  earthElevation: Math.PI * 0.25,
});
// Set camera reference for spaceship light positioning
celestialSystem.setCamera(engine.getCamera());
engine.setCelestialSystem(celestialSystem);

// Initialize shader UI controller (after celestial system so they can be synced)
const shaderUI = new ShaderUIController(terrainManager.getMaterial(), celestialSystem);

// Start the render loop
engine.start();

// Handle cleanup on page unload
window.addEventListener('beforeunload', () => {
  shaderUI.dispose();
  skybox.dispose();
  engine.dispose();
});

// Log instructions to console
console.log('Lunar Explorer - Controls:');
console.log('  Click to enable mouse look');
console.log('  W/S - Forward/Backward');
console.log('  A/D - Strafe Left/Right');
console.log('  Q - Down | E - Up');
console.log('  Shift - Hold for speed boost (3x faster)');
console.log('  Mouse - Look around');
console.log('  Scroll - Adjust speed');
console.log('  Escape - Release mouse');
console.log('  O - Toggle debug wireframe (shows LOD chunks)');

=== src/shaders/EarthMaterial.ts ===
import * as THREE from 'three';

/**
 * Custom Earth material with realistic day/night cycle
 * 
 * Features:
 * - Day side texture with clouds
 * - Night side with city lights
 * - Smooth terminator transition
 * - Atmospheric glow at edges
 * - Cloud layer that only shows on day side
 * 
 * IMPORTANT: Uses world-space normals for lighting calculations.
 * The sunDirection uniform must be in world space (from CelestialSystem).
 */

const earthVertexShader = /* glsl */ `
varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;

void main() {
  vUv = uv;
  // Transform normal to WORLD SPACE (not view space)
  // This is critical: sunDirection from CelestialSystem is in world space,
  // so normals must also be in world space for correct lighting
  vNormal = normalize(mat3(modelMatrix) * normal);
  vPosition = (modelMatrix * vec4(position, 1.0)).xyz;
  
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

const earthFragmentShader = /* glsl */ `
uniform sampler2D dayMap;
uniform sampler2D nightMap;
uniform sampler2D cloudsMap;
uniform sampler2D specularMap;
uniform vec3 sunDirection;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;

void main() {
  vec3 normal = normalize(vNormal);
  
  // Calculate sun-facing amount (-1 = facing away, 1 = facing sun)
  float sunFacing = dot(normal, sunDirection);
  
  // Smooth transition from night to day
  // -0.2 to 0.3 creates a nice terminator region
  float dayStrength = smoothstep(-0.2, 0.3, sunFacing);
  
  // Sample textures
  vec3 dayColor = texture2D(dayMap, vUv).rgb;
  vec3 nightColor = texture2D(nightMap, vUv).rgb;
  float clouds = texture2D(cloudsMap, vUv).r;
  float specular = texture2D(specularMap, vUv).r;
  
  // Add clouds to day side (clouds are white, so add them)
  vec3 dayWithClouds = mix(dayColor, vec3(1.0), clouds * 0.7);
  
  // Night side shows city lights (boost them slightly)
  vec3 nightLights = nightColor * 1.5;
  
  // Mix day and night based on sun facing
  vec3 baseColor = mix(nightLights, dayWithClouds, dayStrength);
  
  // Add atmospheric glow at the terminator (twilight zone)
  float twilightZone = smoothstep(-0.3, 0.0, sunFacing) * smoothstep(0.3, 0.0, sunFacing);
  vec3 twilightColor = vec3(1.0, 0.4, 0.2); // Orange-red twilight
  baseColor = mix(baseColor, twilightColor, twilightZone * 0.3);
  
  // Fresnel effect for atmospheric rim on day side
  vec3 viewDirection = normalize(cameraPosition - vPosition);
  float fresnel = 1.0 - max(dot(viewDirection, normal), 0.0);
  fresnel = pow(fresnel, 3.0);
  
  // Blue atmospheric rim on day side
  vec3 atmosphereColor = vec3(0.3, 0.6, 1.0);
  float atmosphereStrength = fresnel * dayStrength * 0.5;
  baseColor = mix(baseColor, atmosphereColor, atmosphereStrength);
  
  // Add specular highlight on water (day side only)
  vec3 reflectDir = reflect(-sunDirection, normal);
  float spec = pow(max(dot(viewDirection, reflectDir), 0.0), 32.0);
  baseColor += vec3(1.0) * spec * specular * dayStrength * 0.5;
  
  gl_FragColor = vec4(baseColor, 1.0);
}
`;

export interface EarthMaterialOptions {
  dayMapPath: string;
  nightMapPath: string;
  cloudsMapPath: string;
  specularMapPath: string;
}

export class EarthMaterial extends THREE.ShaderMaterial {
  private sunDirectionUniform: THREE.Uniform<THREE.Vector3>;
  
  constructor(options: EarthMaterialOptions) {
    const textureLoader = new THREE.TextureLoader();
    
    // Load textures with proper settings
    const dayMap = textureLoader.load(options.dayMapPath);
    dayMap.colorSpace = THREE.SRGBColorSpace;
    dayMap.anisotropy = 8;
    
    const nightMap = textureLoader.load(options.nightMapPath);
    nightMap.colorSpace = THREE.SRGBColorSpace;
    nightMap.anisotropy = 8;
    
    const cloudsMap = textureLoader.load(options.cloudsMapPath);
    cloudsMap.anisotropy = 8;
    
    const specularMap = textureLoader.load(options.specularMapPath);
    specularMap.anisotropy = 8;
    
    const sunDirectionUniform = new THREE.Uniform(new THREE.Vector3(1, 0, 0));
    
    super({
      vertexShader: earthVertexShader,
      fragmentShader: earthFragmentShader,
      uniforms: {
        dayMap: { value: dayMap },
        nightMap: { value: nightMap },
        cloudsMap: { value: cloudsMap },
        specularMap: { value: specularMap },
        sunDirection: sunDirectionUniform,
      },
    });
    
    this.sunDirectionUniform = sunDirectionUniform;
  }
  
  /**
   * Update the sun direction for the shader
   * @param direction Normalized direction vector pointing toward the sun (in world space)
   */
  setSunDirection(direction: THREE.Vector3): void {
    this.sunDirectionUniform.value.copy(direction);
  }
  
  /**
   * Dispose of material and textures
   */
  dispose(): void {
    const uniforms = this.uniforms;
    (uniforms.dayMap.value as THREE.Texture)?.dispose();
    (uniforms.nightMap.value as THREE.Texture)?.dispose();
    (uniforms.cloudsMap.value as THREE.Texture)?.dispose();
    (uniforms.specularMap.value as THREE.Texture)?.dispose();
    super.dispose();
  }
}

=== src/shaders/ModifiedStandardMaterial.ts ===
import { glslCommon } from './glsl_common';
import { MeshStandardMaterial } from 'three';

export class ModifiedStandardMaterial extends MeshStandardMaterial {
  constructor(insertedGlsl: string) {
    super();

    this.onBeforeCompile = (shader) => {
      shader.vertexShader = `
        #define STANDARD

		attribute vec3 biome;
		varying vec3 v_Biome;

        varying vec3 vViewPosition;
        varying vec3 v_Position;
        varying vec3 v_Normal;
        #ifdef USE_TRANSMISSION
          varying vec3 vWorldPosition;
        #endif
        #include <common>
        #include <batching_pars_vertex>
        #include <uv_pars_vertex>
        #include <displacementmap_pars_vertex>
        #include <color_pars_vertex>
        #include <fog_pars_vertex>
        #include <normal_pars_vertex>
        #include <morphtarget_pars_vertex>
        #include <skinning_pars_vertex>
        #include <shadowmap_pars_vertex>
        #include <logdepthbuf_pars_vertex>
        #include <clipping_planes_pars_vertex>
        void main() {
          #include <uv_vertex>
          #include <color_vertex>
          #include <morphinstance_vertex>
          #include <morphcolor_vertex>
          #include <batching_vertex>
          #include <beginnormal_vertex>
          #include <morphnormal_vertex>
          #include <skinbase_vertex>
          #include <skinnormal_vertex>
          #include <defaultnormal_vertex>
          #include <normal_vertex>
          #include <begin_vertex>
          #include <morphtarget_vertex>
          #include <skinning_vertex>
          #include <displacementmap_vertex>
          #include <project_vertex>
          #include <logdepthbuf_vertex>
          #include <clipping_planes_vertex>
          vViewPosition = - mvPosition.xyz;
          #include <worldpos_vertex>
          #include <shadowmap_vertex>
          #include <fog_vertex>
          
          v_Position = (modelMatrix * vec4(position, 1.0)).xyz;
          v_Normal = normal;
		  v_Biome = biome;
          
        #ifdef USE_TRANSMISSION
          vWorldPosition = worldPosition.xyz;
        #endif
        }
      `;




      shader.fragmentShader = `
#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
varying vec3 vWorldPosition;
varying vec3 v_Position;
varying vec3 v_Normal;
varying vec3 v_Biome;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

${glslCommon}

${insertedGlsl}

void main() {

  vec3 a = vec3(0.1, 1.0, 1.0);
	vec4 diffuseColor = diffuseFn();
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`
    };


  }
}

=== src/shaders/MoonMaterial.ts ===
import { MeshStandardMaterial, Color } from 'three';
import { glslCommon } from './glsl_common';

/**
 * Shader parameters interface for MoonMaterial
 */
export interface MoonMaterialParams {
  // Toggles
  enableCraters: boolean;
  enableNoise: boolean;
  enableColorVariation: boolean;

  // Base parameters
  scale: number; // Crater density (lower = larger craters)
  distortion: number; // Crater "wobble" (0 = perfect circles)
  bumpStrength: number; // Visual depth intensity
  detailScale: number; // Fine detail scale

  // Noise parameters
  noiseFrequency: number; // Noise frequency multiplier
  noiseAmplitude: number; // Noise amplitude
  distortionFrequency: number; // Distortion frequency multiplier

  // Crater parameters
  largeCraterScale: number; // Large crater scale multiplier
  mediumCraterScale: number; // Medium crater scale multiplier
  largeCraterSmoothMin: number; // Large crater smoothstep min
  largeCraterSmoothMax: number; // Large crater smoothstep max
  mediumCraterSmoothMin: number; // Medium crater smoothstep min
  mediumCraterSmoothMax: number; // Medium crater smoothstep max
  largeCraterWeight: number; // Large crater blend weight
  mediumCraterWeight: number; // Medium crater blend weight

  // Color parameters
  colorVariationFrequency: number; // Color variation frequency
  baseColorBlend: number; // Base color blend factor
  brightnessBoost: number; // Brightness boost multiplier

  // Curvature parameters
  enableCurvature: boolean;
  planetRadius: number; // Virtual planet radius in meters
}

/**
 * MoonMaterial - Procedural lunar surface shader
 * 
 * Uses distorted Voronoi noise for crater patterns and procedural bump mapping
 * for visual depth. Works with existing CPU-generated terrain geometry.
 * 
 * Key features:
 * - Coordinate distortion for organic crater shapes (Ryan King Art technique)
 * - Cellular/Voronoi noise for crater patterns
 * - Procedural normal perturbation (bump mapping via finite differences)
 * - Gray lunar color palette with height-based variation
 */
export class MoonMaterial extends MeshStandardMaterial {
  private shaderUniforms: { [key: string]: { value: any } } | null = null;
  private params: MoonMaterialParams;

  constructor() {
    super({
      color: new Color(0xaaaaaa),
      roughness: 0.9, // Moon dust is extremely rough and non-reflective
      metalness: 0.1,
      flatShading: false,
    });

    // Initialize default parameters
    this.params = {
      enableCraters: false,
      enableNoise: true,
      enableColorVariation: true,
      scale: 0.05,
      distortion: 0.35,
      bumpStrength: 0.4,
      detailScale: 0.5,
      noiseFrequency: 8.0,
      noiseAmplitude: 0.06,
      distortionFrequency: 0.5,
      largeCraterScale: 0.5,
      mediumCraterScale: 1.5,
      largeCraterSmoothMin: 0.15,
      largeCraterSmoothMax: 0.85,
      mediumCraterSmoothMin: 0.2,
      mediumCraterSmoothMax: 0.8,
      largeCraterWeight: 0.6,
      mediumCraterWeight: 0.4,
      colorVariationFrequency: 0.005,
      baseColorBlend: 0.6,
      brightnessBoost: 1.2,
      enableCurvature: true,
      planetRadius: 5000,
    };

    this.onBeforeCompile = (shader) => {
      // Store reference to uniforms for later updates
      this.shaderUniforms = shader.uniforms;

      // Initialize all uniforms
      shader.uniforms.uEnableCraters = { value: this.params.enableCraters ? 1.0 : 0.0 };
      shader.uniforms.uEnableNoise = { value: this.params.enableNoise ? 1.0 : 0.0 };
      shader.uniforms.uEnableColorVariation = { value: this.params.enableColorVariation ? 1.0 : 0.0 };
      
      shader.uniforms.uScale = { value: this.params.scale };
      shader.uniforms.uDistortion = { value: this.params.distortion };
      shader.uniforms.uBumpStrength = { value: this.params.bumpStrength };
      shader.uniforms.uDetailScale = { value: this.params.detailScale };
      
      shader.uniforms.uNoiseFrequency = { value: this.params.noiseFrequency };
      shader.uniforms.uNoiseAmplitude = { value: this.params.noiseAmplitude };
      shader.uniforms.uDistortionFrequency = { value: this.params.distortionFrequency };
      
      shader.uniforms.uLargeCraterScale = { value: this.params.largeCraterScale };
      shader.uniforms.uMediumCraterScale = { value: this.params.mediumCraterScale };
      shader.uniforms.uLargeCraterSmoothMin = { value: this.params.largeCraterSmoothMin };
      shader.uniforms.uLargeCraterSmoothMax = { value: this.params.largeCraterSmoothMax };
      shader.uniforms.uMediumCraterSmoothMin = { value: this.params.mediumCraterSmoothMin };
      shader.uniforms.uMediumCraterSmoothMax = { value: this.params.mediumCraterSmoothMax };
      shader.uniforms.uLargeCraterWeight = { value: this.params.largeCraterWeight };
      shader.uniforms.uMediumCraterWeight = { value: this.params.mediumCraterWeight };
      
      
      shader.uniforms.uColorVariationFrequency = { value: this.params.colorVariationFrequency };
      shader.uniforms.uBaseColorBlend = { value: this.params.baseColorBlend };
      shader.uniforms.uBrightnessBoost = { value: this.params.brightnessBoost };
      
      shader.uniforms.uEnableCurvature = { value: this.params.enableCurvature ? 1.0 : 0.0 };
      shader.uniforms.uPlanetRadius = { value: this.params.planetRadius };

      // ==========================================
      // VERTEX SHADER MODIFICATIONS
      // ==========================================
      
      // Add varying for world position
      shader.vertexShader = `
        varying vec3 vWorldPosition;
        uniform float uEnableCurvature;
        uniform float uPlanetRadius;
        ${shader.vertexShader}
      `;

      // Pass world position to fragment shader
      shader.vertexShader = shader.vertexShader.replace(
        '#include <worldpos_vertex>',
        `
        #include <worldpos_vertex>
        vWorldPosition = (modelMatrix * vec4(transformed, 1.0)).xyz;
        `
      );

      // Apply planetary curvature
      shader.vertexShader = shader.vertexShader.replace(
        '#include <project_vertex>',
        `
        vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
        
        if (uEnableCurvature > 0.5) {
          vec2 deltaXZ = worldPosition.xz - cameraPosition.xz;
          float distSq = dot(deltaXZ, deltaXZ);
          float curvatureDrop = distSq / (2.0 * uPlanetRadius);
          worldPosition.y -= curvatureDrop;
        }
        
        vec4 mvPosition = viewMatrix * worldPosition;
        gl_Position = projectionMatrix * mvPosition;
        `
      );

      // ==========================================
      // FRAGMENT SHADER MODIFICATIONS
      // ==========================================

      // Add uniforms, varyings, and noise functions
      shader.fragmentShader = `
        varying vec3 vWorldPosition;
        
        // Toggle uniforms
        uniform float uEnableCraters;
        uniform float uEnableNoise;
        uniform float uEnableColorVariation;
        
        // Base parameters
        uniform float uScale;
        uniform float uDistortion;
        uniform float uBumpStrength;
        uniform float uDetailScale;
        
        // Noise parameters
        uniform float uNoiseFrequency;
        uniform float uNoiseAmplitude;
        uniform float uDistortionFrequency;
        
        // Crater parameters
        uniform float uLargeCraterScale;
        uniform float uMediumCraterScale;
        uniform float uLargeCraterSmoothMin;
        uniform float uLargeCraterSmoothMax;
        uniform float uMediumCraterSmoothMin;
        uniform float uMediumCraterSmoothMax;
        uniform float uLargeCraterWeight;
        uniform float uMediumCraterWeight;
        
        // Color parameters
        uniform float uColorVariationFrequency;
        uniform float uBaseColorBlend;
        uniform float uBrightnessBoost;

        ${glslCommon}

        // ==========================================
        // OPTIMIZED 2D CELLULAR NOISE (for craters)
        // Using 2D instead of 3D - terrain is essentially a heightfield
        // ==========================================
        
        float cellular2D(vec2 P) {
          vec2 Pi = floor(P);
          vec2 Pf = P - Pi;
          
          float d = 1e30;
          
          // Search 3x3 neighborhood (9 iterations vs 27 for 3D)
          for (int i = -1; i <= 1; i++) {
            for (int j = -1; j <= 1; j++) {
              vec2 offset = vec2(float(i), float(j));
              vec2 cellPos = Pi + offset;
              
              // Simple hash for random offset
              vec2 p = fract(sin(vec2(
                dot(cellPos, vec2(127.1, 311.7)),
                dot(cellPos, vec2(269.5, 183.3))
              )) * 43758.5453);
              
              vec2 pointPos = offset + p - Pf;
              float dist = length(pointPos);
              d = min(d, dist);
            }
          }
          
          return d;
        }

        // ==========================================
        // OPTIMIZED LUNAR SURFACE HEIGHT FUNCTION
        // ==========================================
        
        float getSurfaceHeight(vec2 pos) {
          float scale = uScale;
          float height = 0.0;
          
          // A. Noise detail (if enabled)
          float noise = 0.0;
          if (uEnableNoise > 0.5) {
            noise = simplexNoise(pos * scale * uNoiseFrequency) * uNoiseAmplitude;
            height += noise;
          }
          
          // B. Craters (if enabled)
          if (uEnableCraters > 0.5) {
            // Distortion calculation
            float distortion = simplexNoise(pos * scale * uDistortionFrequency);
            vec2 distortedPos = pos + vec2(distortion) * uDistortion;
            
            // Large craters
            float largeCraters = 1.0 - cellular2D(distortedPos * scale * uLargeCraterScale);
            largeCraters = smoothstep(uLargeCraterSmoothMin, uLargeCraterSmoothMax, largeCraters);
            
            // Medium craters
            vec2 distortedPos2 = pos + vec2(distortion * 0.7) + vec2(100.0);
            float mediumCraters = 1.0 - cellular2D(distortedPos2 * scale * uMediumCraterScale);
            mediumCraters = smoothstep(uMediumCraterSmoothMin, uMediumCraterSmoothMax, mediumCraters);
            
            // Combine crater layers
            float craters = largeCraters * uLargeCraterWeight + mediumCraters * uMediumCraterWeight;
            height += craters;
          }
          
          return height;
        }


        ${shader.fragmentShader}
      `;

      // ==========================================
      // INJECT HEIGHT CALCULATION EARLY (before color_fragment)
      // Uses screen-space derivatives for gradient - only 1 height sample!
      // ==========================================
      
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <color_fragment>',
        `
        // Calculate terrain position and surface height for coloring
        vec2 terrainPos = vWorldPosition.xz;
        float surfaceHeight = getSurfaceHeight(terrainPos);
        
        #include <color_fragment>
        
        // Lunar color palette
        vec3 darkMoon = vec3(0.08, 0.08, 0.10);    // Deep crater bottoms
        vec3 lightMoon = vec3(0.55, 0.53, 0.51);   // Crater rims / fresh ejecta
        
        // Large-scale color variation (mare vs highlands) - if enabled
        vec3 baseColor = vec3(0.25, 0.24, 0.23); // Default mid-tone
        if (uEnableColorVariation > 0.5) {
          float largeVariation = simplexNoise(terrainPos * uColorVariationFrequency) * 0.5 + 0.5;
          vec3 mareColor = vec3(0.12, 0.11, 0.13);   // Darker mare basalt
          vec3 highlandsColor = vec3(0.35, 0.33, 0.31); // Lighter highlands
          baseColor = mix(mareColor, highlandsColor, smoothstep(0.3, 0.7, largeVariation));
        }
        
        // Height-based coloring (craters are darker, rims are lighter)
        vec3 surfaceColor = mix(darkMoon, lightMoon, surfaceHeight);
        
        // Blend base color with height-based color
        surfaceColor = mix(baseColor, surfaceColor, uBaseColorBlend);
        
        // Add subtle noise to albedo to match regolith roughness (only if noise enabled)
        if (uEnableNoise > 0.5) {
          float albedoNoise = simplexNoise(terrainPos * 50.0) * 0.02;
          surfaceColor += vec3(albedoNoise);
        }

        diffuseColor.rgb *= surfaceColor * uBrightnessBoost;
        `
      );
      
      // ==========================================
    };
  }

  /**
   * Update a parameter and refresh uniforms
   */
  setParam<K extends keyof MoonMaterialParams>(key: K, value: MoonMaterialParams[K]): void {
    this.params[key] = value;
    this.updateUniforms();
  }

  /**
   * Get a parameter value
   */
  getParam<K extends keyof MoonMaterialParams>(key: K): MoonMaterialParams[K] {
    return this.params[key];
  }

  /**
   * Get all parameters
   */
  getParams(): MoonMaterialParams {
    return { ...this.params };
  }

  /**
   * Set all parameters at once
   */
  setParams(params: Partial<MoonMaterialParams>): void {
    Object.assign(this.params, params);
    this.updateUniforms();
  }

  /**
   * Update shader uniforms from current parameters
   */
  private updateUniforms(): void {
    if (!this.shaderUniforms) return;

    // Update toggle uniforms (convert boolean to float)
    this.shaderUniforms.uEnableCraters.value = this.params.enableCraters ? 1.0 : 0.0;
    this.shaderUniforms.uEnableNoise.value = this.params.enableNoise ? 1.0 : 0.0;
    this.shaderUniforms.uEnableColorVariation.value = this.params.enableColorVariation ? 1.0 : 0.0;

    // Update base parameters
    this.shaderUniforms.uScale.value = this.params.scale;
    this.shaderUniforms.uDistortion.value = this.params.distortion;
    this.shaderUniforms.uBumpStrength.value = this.params.bumpStrength;
    this.shaderUniforms.uDetailScale.value = this.params.detailScale;

    // Update noise parameters
    this.shaderUniforms.uNoiseFrequency.value = this.params.noiseFrequency;
    this.shaderUniforms.uNoiseAmplitude.value = this.params.noiseAmplitude;
    this.shaderUniforms.uDistortionFrequency.value = this.params.distortionFrequency;

    // Update crater parameters
    this.shaderUniforms.uLargeCraterScale.value = this.params.largeCraterScale;
    this.shaderUniforms.uMediumCraterScale.value = this.params.mediumCraterScale;
    this.shaderUniforms.uLargeCraterSmoothMin.value = this.params.largeCraterSmoothMin;
    this.shaderUniforms.uLargeCraterSmoothMax.value = this.params.largeCraterSmoothMax;
    this.shaderUniforms.uMediumCraterSmoothMin.value = this.params.mediumCraterSmoothMin;
    this.shaderUniforms.uMediumCraterSmoothMax.value = this.params.mediumCraterSmoothMax;
    this.shaderUniforms.uLargeCraterWeight.value = this.params.largeCraterWeight;
    this.shaderUniforms.uMediumCraterWeight.value = this.params.mediumCraterWeight;


    // Update color parameters
    this.shaderUniforms.uColorVariationFrequency.value = this.params.colorVariationFrequency;
    this.shaderUniforms.uBaseColorBlend.value = this.params.baseColorBlend;
    this.shaderUniforms.uBrightnessBoost.value = this.params.brightnessBoost;

    // Update curvature parameters
    this.shaderUniforms.uEnableCurvature.value = this.params.enableCurvature ? 1.0 : 0.0;
    this.shaderUniforms.uPlanetRadius.value = this.params.planetRadius;

    // Mark material as needing update
    this.needsUpdate = true;
  }
}

=== src/shaders/SunMaterial.ts ===
import * as THREE from 'three';

/**
 * Custom Sun material with intense emissive glow
 * 
 * The sun appears as a bright glowing sphere that will trigger
 * the bloom post-processing effect. Uses a custom shader for
 * a realistic solar appearance with limb darkening.
 */

const sunVertexShader = /* glsl */ `
varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vViewPosition;

void main() {
  vUv = uv;
  vNormal = normalize(normalMatrix * normal);
  
  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
  vViewPosition = -mvPosition.xyz;
  
  gl_Position = projectionMatrix * mvPosition;
}
`;

const sunFragmentShader = /* glsl */ `
uniform vec3 sunColor;
uniform float intensity;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vViewPosition;

void main() {
  vec3 normal = normalize(vNormal);
  vec3 viewDir = normalize(vViewPosition);
  
  // Limb darkening - edges of sun appear slightly darker
  float cosAngle = max(dot(normal, viewDir), 0.0);
  
  // Limb darkening coefficients (realistic solar values)
  float limbDarkening = 0.3 + 0.7 * pow(cosAngle, 0.5);
  
  // Corona/glow effect at edges
  float edge = 1.0 - cosAngle;
  float corona = pow(edge, 2.0) * 0.5;
  
  // Final color with high intensity for bloom
  vec3 color = sunColor * intensity * limbDarkening;
  
  // Add slight orange tint to corona
  vec3 coronaColor = vec3(1.0, 0.8, 0.4) * intensity * corona;
  color += coronaColor;
  
  gl_FragColor = vec4(color, 1.0);
}
`;

export interface SunMaterialOptions {
  color?: THREE.Color | number;
  intensity?: number;
}

export class SunMaterial extends THREE.ShaderMaterial {
  constructor(options: SunMaterialOptions = {}) {
    const color = options.color instanceof THREE.Color 
      ? options.color 
      : new THREE.Color(options.color ?? 0xffffee);
    
    const intensity = options.intensity ?? 3.0;
    
    super({
      vertexShader: sunVertexShader,
      fragmentShader: sunFragmentShader,
      uniforms: {
        sunColor: { value: color },
        intensity: { value: intensity },
      },
      // Disable depth write so sun doesn't occlude stars
      depthWrite: false,
      // Render after skybox but before terrain
      transparent: false,
    });
  }
  
  /**
   * Set the sun color
   */
  setColor(color: THREE.Color | number): void {
    if (color instanceof THREE.Color) {
      this.uniforms.sunColor.value.copy(color);
    } else {
      this.uniforms.sunColor.value.set(color);
    }
  }
  
  /**
   * Set the intensity (affects bloom strength)
   */
  setIntensity(intensity: number): void {
    this.uniforms.intensity.value = intensity;
  }
}

=== src/shaders/TerrainMaterial.ts ===
import { ModifiedStandardMaterial } from './ModifiedStandardMaterial';


export class TerrainMaterial extends ModifiedStandardMaterial {

  constructor() {
    super(`
    vec4 diffuseFn() {
      float noise = fbm(v_Position.xz * 3.0, 5);
    
      vec2 p_dist_grass = distortCoords(v_Position.xy, 1.1, noise);
      float map_grass = clamp(map(p_dist_grass.y, 1.0, 0.8, 0.0, 1.0), 0.0, 1.0);
      
      vec2 p_dist_rock = distortCoords(v_Normal.xy, 0.5, noise);
      float map_rock = clamp(pow(map(p_dist_rock.y, 0.56, 0.67, 1.0, 0.0), 1.0), 0.0, 1.0);
      
      vec4 ground_color_low = mix(
        vec4(0.7, 0.42, 0.19, 1.0),
        vec4(0.30, 0.83, 0.10, 1.0),
        v_Biome.x); 

      vec4 ground_color_high = mix(
        vec4(0.4, 0.2, 0.4, 1.0),
        vec4(0.48, 0.57, 0.69, 1.0),
        v_Biome.x); 

      vec4 ground_variation_color = mix(
        vec4(0.4, 0.26, 0.10, 1.0),
        vec4(0.06, 0.4, 0.10, 1.0),
        v_Biome.x);

      vec4 sand_color = mix(
        vec4(0.6, 0.32, 0.14, 1.0),
        vec4(0.95, 0.95, 0.95, 1.0),
        v_Biome.x);
      
      vec4 rock_color = mix(
        vec4(0.2959, 0.1592, 0.0540, 1.0),
        vec4(0.45, 0.45, 0.55, 1.0),
        v_Biome.x);
        
      
      vec4 water_color = vec4(0.0191, 0.0476, 0.2057, 1.0);

      float ground_variation = clamp(pow(fbm(v_Position.xz * 0.03, 2) + 0.3, 5.0), 0.0, 1.0);
      
      vec4 ground_color = mix(ground_color_low, ground_color_high,
        clamp(map(v_Position.y, -0.0, 2.0, 0.0, 1.0), 0.0, 1.0)
      );
      
      ground_color = mix(ground_color, ground_variation_color, ground_variation);
      
      vec4 snow_grass = mix(sand_color, ground_color, map_grass);
      
      vec4 texture_rock_default = mix(rock_color, vec4(0.22, 0.24, 0.3, 1.0), pow(fbm(v_Position.xz * 3.0, 3), 0.5) * 0.4);
      
      vec4 terrain_texture = mix(snow_grass, texture_rock_default, map_rock);
      float rivers = clamp( pow(v_Biome.y * 2.0, 3.0), 0.0, 1.0) * 0.9;
      return mix(terrain_texture, water_color, rivers);
    }
    `);
  }
}

=== src/shaders/glsl_common.ts ===
export const glslCommon = `
  // ==========================================
  // COMMON NOISE UTILITIES
  // ==========================================
  
  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
  vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
  vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

  // ==========================================
  // 2D SIMPLEX NOISE
  // ==========================================
  
  float simplexNoise(vec2 v) {
    v *= 0.5;
    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
    vec2 i = floor(v + dot(v, C.yy));
    vec2 x0 = v - i + dot(i, C.xx);
    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec2 x1 = x0.xy + C.xx - i1;
    vec2 x2 = x0.xy + C.zz;
    i = mod289(i);
    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
    m = m * m;
    m = m * m;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
    vec3 g = vec3(0.0);
    g.x = a0.x * x0.x + h.x * x0.y;
    g.yz = a0.yz * vec2(x1.x, x2.x) + h.yz * vec2(x1.y, x2.y);
    return 130.0 * dot(m, g);
  }

  // ==========================================
  // 3D SIMPLEX NOISE (for coordinate distortion)
  // ==========================================
  
  float snoise3D(vec3 v) {
    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
    
    // First corner
    vec3 i = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);
    
    // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);
    
    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;
    
    // Permutations
    i = mod289(i);
    vec4 p = permute(permute(permute(
              i.z + vec4(0.0, i1.z, i2.z, 1.0))
            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
    
    // Gradients
    float n_ = 0.142857142857;
    vec3 ns = n_ * D.wyz - D.xzx;
    
    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_);
    
    vec4 x = x_ * ns.x + ns.yyyy;
    vec4 y = y_ * ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);
    
    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);
    
    vec4 s0 = floor(b0) * 2.0 + 1.0;
    vec4 s1 = floor(b1) * 2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
    
    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
    
    vec3 p0 = vec3(a0.xy, h.x);
    vec3 p1 = vec3(a0.zw, h.y);
    vec3 p2 = vec3(a1.xy, h.z);
    vec3 p3 = vec3(a1.zw, h.w);
    
    // Normalize gradients
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    
    // Mix contributions
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot(m * m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
  }

  // ==========================================
  // CELLULAR/VORONOI NOISE (for craters)
  // ==========================================
  
  float cellular(vec3 P) {
    vec3 Pi = floor(P);
    vec3 Pf = P - Pi;
    
    float d = 1e30;
    
    // Search 3x3x3 neighborhood
    for (int i = -1; i <= 1; i++) {
      for (int j = -1; j <= 1; j++) {
        for (int k = -1; k <= 1; k++) {
          vec3 offset = vec3(float(i), float(j), float(k));
          vec3 cellPos = Pi + offset;
          
          // Hash to get random point position within cell
          vec3 p = permute(permute(permute(
                    mod289(vec3(cellPos.x))) + 
                    mod289(vec3(cellPos.y))) + 
                    mod289(vec3(cellPos.z)));
          
          // Random offset within cell (0-1 range)
          vec3 randomOffset = fract(p * vec3(0.1031, 0.1030, 0.0973));
          
          // Point position
          vec3 pointPos = offset + randomOffset - Pf;
          
          // Distance to point (squared for efficiency, but we need actual distance for crater shape)
          float dist = length(pointPos);
          d = min(d, dist);
        }
      }
    }
    
    return d;
  }

  // ==========================================
  // FBM (Fractal Brownian Motion)
  // ==========================================
  
  float fbm(in vec2 st, int OCTAVES) {
    int maxOctaves = 16;
    OCTAVES = clamp(OCTAVES, 1, maxOctaves);
    float value = 0.0;
    float amplitude = 0.5;
    
    for (int i = 0; i < OCTAVES; i++) {
      value += amplitude * (simplexNoise(st) * 0.5 + 0.5);
      st *= 2.0;
      amplitude *= 0.5;
    }
    return value;
  }
  
  float fbm3D(in vec3 st, int OCTAVES) {
    int maxOctaves = 16;
    OCTAVES = clamp(OCTAVES, 1, maxOctaves);
    float value = 0.0;
    float amplitude = 0.5;
    
    for (int i = 0; i < OCTAVES; i++) {
      value += amplitude * (snoise3D(st) * 0.5 + 0.5);
      st *= 2.0;
      amplitude *= 0.5;
    }
    return value;
  }

  // ==========================================
  // UTILITY FUNCTIONS
  // ==========================================
  
  vec2 distortCoords(in vec2 st, in float strength, in float map) {
    map -= 0.5;
    vec2 ou = st + map * strength;
    return ou;
  }
  
  float map(float value, float min1, float max1, float min2, float max2) {
    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
  }
`;

=== src/terrain/ChunkRequestQueue.spec.ts ===
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { Vector3 } from 'three';
import {
  ChunkRequestQueue,
  defaultPriorityCalculator,
  type QueuedRequest,
  type ChunkConfig,
} from './ChunkRequestQueue';
import type { TerrainArgs } from './terrain';

describe(ChunkRequestQueue.name, () => {
  const chunkConfig: ChunkConfig = { chunkWidth: 50, chunkDepth: 50 };
  let queue: ChunkRequestQueue;

  beforeEach(() => {
    queue = new ChunkRequestQueue(chunkConfig);
  });

  describe('add', () => {
    it('should add request to queue', () => {
      const request = createMockRequest('0,0', 0);
      
      const result = queue.add(request);

      expect(result).toBe(true);
      expect(queue.length).toBe(1);
    });

    it('should not add duplicate requests with same gridKey and lodLevel', () => {
      const request1 = createMockRequest('0,0', 0);
      const request2 = createMockRequest('0,0', 0);

      queue.add(request1);
      const result = queue.add(request2);

      expect(result).toBe(false);
      expect(queue.length).toBe(1);
    });

    it('should allow same gridKey with different lodLevel', () => {
      const request1 = createMockRequest('0,0', 0);
      const request2 = createMockRequest('0,0', 1);

      queue.add(request1);
      queue.add(request2);

      expect(queue.length).toBe(2);
    });
  });

  describe('has', () => {
    it('should return true for queued request', () => {
      queue.add(createMockRequest('1,2', 0));

      expect(queue.has('1,2', 0)).toBe(true);
    });

    it('should return false for non-queued request', () => {
      queue.add(createMockRequest('1,2', 0));

      expect(queue.has('1,2', 1)).toBe(false);
      expect(queue.has('0,0', 0)).toBe(false);
    });
  });

  describe('pruneStale', () => {
    it('should remove requests not in valid set', () => {
      queue.add(createMockRequest('0,0', 0));
      queue.add(createMockRequest('1,1', 0));
      queue.add(createMockRequest('2,2', 0));

      queue.pruneStale(new Set(['0,0', '2,2']));

      expect(queue.length).toBe(2);
      expect(queue.has('0,0', 0)).toBe(true);
      expect(queue.has('1,1', 0)).toBe(false);
      expect(queue.has('2,2', 0)).toBe(true);
    });

    it('should keep all requests when all are valid', () => {
      queue.add(createMockRequest('0,0', 0));
      queue.add(createMockRequest('1,1', 0));

      queue.pruneStale(new Set(['0,0', '1,1', '2,2']));

      expect(queue.length).toBe(2);
    });

    it('should remove all requests when none are valid', () => {
      queue.add(createMockRequest('0,0', 0));
      queue.add(createMockRequest('1,1', 0));

      queue.pruneStale(new Set(['3,3']));

      expect(queue.length).toBe(0);
    });
  });

  describe('sort', () => {
    it('should sort by priority with closest chunks first', () => {
      // Arrange - camera at origin, looking forward (+Z)
      const cameraPos = new Vector3(0, 0, 0);
      const cameraForward = new Vector3(0, 0, 1);

      // Add chunks at different distances (chunk centers at gridX*50+25, gridZ*50+25)
      queue.add(createMockRequest('2,0', 0)); // Far: center at (125, 25)
      queue.add(createMockRequest('0,0', 0)); // Close: center at (25, 25)
      queue.add(createMockRequest('1,0', 0)); // Medium: center at (75, 25)

      // Act
      queue.sort(cameraPos, cameraForward, new Set());

      // Assert - closest should be first
      expect(queue.shift()?.gridKey).toBe('0,0');
      expect(queue.shift()?.gridKey).toBe('1,0');
      expect(queue.shift()?.gridKey).toBe('2,0');
    });

    it('should prioritize chunks in front of camera over chunks behind', () => {
      // Arrange - camera at (100, 0, 100), looking forward (+Z)
      const cameraPos = new Vector3(100, 0, 100);
      const cameraForward = new Vector3(0, 0, 1);

      // Add two chunks at similar distances: one in front, one behind
      // Chunk at (2,3) = center at (125, 175) - in front (higher Z)
      // Chunk at (2,1) = center at (125, 75) - behind (lower Z)
      queue.add(createMockRequest('2,1', 0)); // Behind
      queue.add(createMockRequest('2,3', 0)); // In front

      // Act
      queue.sort(cameraPos, cameraForward, new Set());

      // Assert - chunk in front should have priority
      expect(queue.shift()?.gridKey).toBe('2,3');
      expect(queue.shift()?.gridKey).toBe('2,1');
    });

    it('should use injected priority calculator', () => {
      // Arrange
      const mockCalculator = vi.fn(() => 0);
      const customQueue = new ChunkRequestQueue(chunkConfig, {
        calculatePriority: mockCalculator,
      });
      customQueue.add(createMockRequest('0,0', 0));
      customQueue.add(createMockRequest('1,1', 0));

      const cameraPos = new Vector3(0, 0, 0);
      const cameraForward = new Vector3(0, 0, 1);

      // Act
      customQueue.sort(cameraPos, cameraForward, new Set());

      // Assert - with 2 items, sort calls comparator once (2 calls to calculatePriority)
      expect(mockCalculator).toHaveBeenCalledTimes(2);
      expect(mockCalculator).toHaveBeenCalledWith('0,0', cameraPos, cameraForward, chunkConfig, new Set());
      expect(mockCalculator).toHaveBeenCalledWith('1,1', cameraPos, cameraForward, chunkConfig, new Set());
    });
  });

  describe('shift', () => {
    it('should return and remove first item', () => {
      queue.add(createMockRequest('0,0', 0));
      queue.add(createMockRequest('1,1', 1));

      const item = queue.shift();

      expect(item?.gridKey).toBe('0,0');
      expect(queue.length).toBe(1);
    });

    it('should return undefined when queue is empty', () => {
      expect(queue.shift()).toBeUndefined();
    });
  });

  describe('clear', () => {
    it('should remove all items from queue', () => {
      queue.add(createMockRequest('0,0', 0));
      queue.add(createMockRequest('1,1', 0));

      queue.clear();

      expect(queue.length).toBe(0);
    });
  });
});

describe(defaultPriorityCalculator.name, () => {
  const chunkConfig: ChunkConfig = { chunkWidth: 50, chunkDepth: 50 };

  it('should give chunk in front of camera lower priority value than chunk behind', () => {
    const cameraPos = new Vector3(25, 0, 25);
    const cameraForward = new Vector3(0, 0, 1);
    const nearestChunkKeys = new Set<string>();

    // Calculate priority for chunk in front vs behind
    const frontPriority = defaultPriorityCalculator(
      '0,2', // In front (higher Z)
      cameraPos,
      cameraForward,
      chunkConfig,
      nearestChunkKeys
    );
    const behindPriority = defaultPriorityCalculator(
      '0,-2', // Behind (lower Z)
      cameraPos,
      cameraForward,
      chunkConfig,
      nearestChunkKeys
    );

    // Front should have lower priority value (= higher priority)
    expect(frontPriority).toBeLessThan(behindPriority);
  });

  it('should return lower priority for closer chunks', () => {
    const cameraPos = new Vector3(0, 0, 0);
    const cameraForward = new Vector3(1, 0, 0); // Looking right, neutral for Z axis
    const nearestChunkKeys = new Set<string>();

    const closePriority = defaultPriorityCalculator(
      '0,0', // Center at (25, 25)
      cameraPos,
      cameraForward,
      chunkConfig,
      nearestChunkKeys
    );
    const farPriority = defaultPriorityCalculator(
      '3,3', // Center at (175, 175)
      cameraPos,
      cameraForward,
      chunkConfig,
      nearestChunkKeys
    );

    expect(closePriority).toBeLessThan(farPriority);
  });

  it('should prioritize nearest chunks over all others', () => {
    const cameraPos = new Vector3(0, 0, 0);
    const cameraForward = new Vector3(0, 0, 1);
    const nearestChunkKeys = new Set(['2,2']); // Mark this as nearest

    // Nearest chunk should get highest priority (very low value)
    const nearestPriority = defaultPriorityCalculator(
      '2,2',
      cameraPos,
      cameraForward,
      chunkConfig,
      nearestChunkKeys
    );

    // Non-nearest chunk should get normal priority
    const normalPriority = defaultPriorityCalculator(
      '0,0',
      cameraPos,
      cameraForward,
      chunkConfig,
      nearestChunkKeys
    );

    // Nearest should have much lower priority value (= much higher priority)
    expect(nearestPriority).toBeLessThan(normalPriority);
    expect(nearestPriority).toBe(-1000000);
  });
});

// Helper functions at bottom of file

function createMockRequest(gridKey: string, lodLevel: number): QueuedRequest {
  return {
    gridKey,
    lodLevel,
    terrainArgs: createMockTerrainArgs(),
  };
}

function createMockTerrainArgs(): TerrainArgs {
  return {
    seed: 0,
    gain: 0.5,
    lacunarity: 2,
    frequency: 0.07,
    amplitude: 0.5,
    altitude: 0.1,
    falloff: 0.0,
    erosion: 0.6,
    erosionSoftness: 0.3,
    rivers: 0.18,
    riverWidth: 0.35,
    riverFalloff: 0.06,
    lakes: 0.5,
    lakesFalloff: 0.5,
    riversFrequency: 0.13,
    smoothLowerPlanes: 0,
    octaves: 10,
    width: 50,
    depth: 50,
    resolution: 128,
    posX: 0,
    posZ: 0,
    renderDistance: 10,
  };
}

=== src/terrain/ChunkRequestQueue.ts ===
import { Vector3 } from 'three';
import type { TerrainArgs } from './terrain';
import { parseGridKey, getChunkWorldCenter } from './LodUtils';

/**
 * A queued chunk generation request
 */
export interface QueuedRequest {
  gridKey: string;
  lodLevel: number;
  terrainArgs: TerrainArgs;
}

/**
 * Configuration for chunk dimensions (needed for priority calculation)
 */
export interface ChunkConfig {
  chunkWidth: number;
  chunkDepth: number;
}

/**
 * Dependencies for ChunkRequestQueue (for testability)
 */
export interface ChunkRequestQueueDependencies {
  calculatePriority: (
    gridKey: string,
    cameraPos: Vector3,
    cameraForward: Vector3,
    chunkConfig: ChunkConfig,
    nearestChunkKeys: Set<string>,
    lodLevel?: number,
    maxLodLevel?: number
  ) => number;
}

/**
 * Calculate priority for a chunk based on distance and camera direction.
 * Lower values = higher priority.
 * 
 * @param gridKey - The chunk's grid key (e.g., "1,2")
 * @param cameraPos - Camera world position
 * @param cameraForward - Camera forward direction (normalized)
 * @param chunkConfig - Chunk dimensions
 * @param nearestChunkKeys - Set of nearest 10 chunk keys (by distance)
 * @returns Priority value (lower = higher priority)
 */
export function defaultPriorityCalculator(
  gridKey: string,
  cameraPos: Vector3,
  cameraForward: Vector3,
  chunkConfig: ChunkConfig,
  nearestChunkKeys: Set<string>,
  lodLevel?: number,
  maxLodLevel?: number
): number {
  // Calculate distance and direction FIRST (used by all tiers)
  const [gridX, gridZ] = parseGridKey(gridKey);
  const chunkCenter = getChunkWorldCenter(
    gridX,
    gridZ,
    chunkConfig.chunkWidth,
    chunkConfig.chunkDepth
  );

  // Calculate distance from camera to chunk center (2D, ignoring Y)
  const dx = chunkCenter.x - cameraPos.x;
  const dz = chunkCenter.z - cameraPos.z;
  const distance = Math.sqrt(dx * dx + dz * dz);

  // Calculate direction to chunk (normalized, 2D)
  const dirLength = distance > 0.001 ? distance : 1;
  const dirX = dx / dirLength;
  const dirZ = dz / dirLength;

  // Dot product with camera forward (2D, ignoring Y)
  const dot = dirX * cameraForward.x + dirZ * cameraForward.z;

  // Direction factor: chunks in front get bonus (lower value)
  // Scale appropriately for each tier
  const directionFactor = -dot * 500;

  const isCoarsest = lodLevel !== undefined && maxLodLevel !== undefined && lodLevel === maxLodLevel;
  const isNearest = nearestChunkKeys.has(gridKey);

  // Tier 1: Nearest 25 chunks (Top Priority)
  if (isNearest) {
    // lodPriority ensures coarsest of near chunks build first
    // Subtract lodLevel from maxLodLevel so highest lodLevel (lowest detail) has SMALLEST value
    const lodPriority = (lodLevel !== undefined && maxLodLevel !== undefined)
      ? (maxLodLevel - lodLevel) * 10000
      : 0;
    return -20000000 + distance + directionFactor + lodPriority;
  }

  // Tier 2: Horizon Fill (Coarsest LOD for all others)
  if (isCoarsest) {
    return -10000000 + distance + directionFactor;
  }

  // Tier 3: Standard progressive detail
  const lodPriority = (lodLevel !== undefined && maxLodLevel !== undefined)
    ? (maxLodLevel - lodLevel) * 1000000
    : 0;

  return distance + directionFactor + lodPriority;
}

const defaultDependencies: ChunkRequestQueueDependencies = {
  calculatePriority: defaultPriorityCalculator,
};

/**
 * Priority queue for chunk generation requests.
 * Supports re-sorting based on camera position and pruning stale requests.
 */
export class ChunkRequestQueue {
  private queue: QueuedRequest[] = [];
  private queuedSet: Set<string> = new Set(); // O(1) lookup: "gridKey:lodLevel"
  private dependencies: ChunkRequestQueueDependencies;
  private chunkConfig: ChunkConfig;

  constructor(
    chunkConfig: ChunkConfig,
    dependencyOverrides?: Partial<ChunkRequestQueueDependencies>
  ) {
    this.chunkConfig = chunkConfig;
    this.dependencies = { ...defaultDependencies, ...dependencyOverrides };
  }

  /**
   * Generate a unique key for a chunk+LOD combination
   */
  private getRequestKey(gridKey: string, lodLevel: number): string {
    return `${gridKey}:${lodLevel}`;
  }

  /**
   * Add a request to the queue if not already present.
   * @returns true if added, false if duplicate
   */
  add(request: QueuedRequest): boolean {
    const key = this.getRequestKey(request.gridKey, request.lodLevel);
    if (this.queuedSet.has(key)) {
      return false;
    }
    this.queue.push(request);
    this.queuedSet.add(key);
    return true;
  }

  /**
   * Check if a request for the given chunk and LOD level is already queued.
   */
  has(gridKey: string, lodLevel: number): boolean {
    const key = this.getRequestKey(gridKey, lodLevel);
    return this.queuedSet.has(key);
  }

  /**
   * Remove requests for chunks not in the valid set.
   * Call this to prune chunks that are no longer in render distance.
   */
  pruneStale(validKeys: Set<string>): void {
    this.queue = this.queue.filter((req) => {
      const isValid = validKeys.has(req.gridKey);
      if (!isValid) {
        const key = this.getRequestKey(req.gridKey, req.lodLevel);
        this.queuedSet.delete(key);
      }
      return isValid;
    });
  }

  /**
   * Sort the queue by priority (lowest priority value first).
   * Should be called each frame after camera moves.
   * 
   * @param cameraPos - Camera world position
   * @param cameraForward - Camera forward direction (normalized)
   * @param nearestChunkKeys - Set of nearest 10 chunk keys (by distance)
   */
  sort(
    cameraPos: Vector3,
    cameraForward: Vector3,
    nearestChunkKeys: Set<string>,
    maxLodLevel?: number
  ): void {
    this.queue.sort((a, b) => {
      const priorityA = this.dependencies.calculatePriority(
        a.gridKey,
        cameraPos,
        cameraForward,
        this.chunkConfig,
        nearestChunkKeys,
        a.lodLevel,
        maxLodLevel
      );
      const priorityB = this.dependencies.calculatePriority(
        b.gridKey,
        cameraPos,
        cameraForward,
        this.chunkConfig,
        nearestChunkKeys,
        b.lodLevel,
        maxLodLevel
      );
      return priorityA - priorityB;
    });
  }

  /**
   * Remove and return the first request matching any of the priority keys,
   * skipping those already in flight.
   */
  shiftMatching(priorityKeys: Set<string>, inFlight: Set<string>): QueuedRequest | undefined {
    const index = this.queue.findIndex((req) => {
      const key = this.getRequestKey(req.gridKey, req.lodLevel);
      return priorityKeys.has(req.gridKey) && !inFlight.has(key);
    });

    if (index !== -1) {
      const request = this.queue.splice(index, 1)[0];
      const key = this.getRequestKey(request.gridKey, request.lodLevel);
      this.queuedSet.delete(key);
      return request;
    }
    return undefined;
  }

  /**
   * Remove and return the first request that is not already in flight.
   */
  shiftAny(inFlight: Set<string>): QueuedRequest | undefined {
    const index = this.queue.findIndex((req) => {
      const key = this.getRequestKey(req.gridKey, req.lodLevel);
      return !inFlight.has(key);
    });

    if (index !== -1) {
      const request = this.queue.splice(index, 1)[0];
      const key = this.getRequestKey(request.gridKey, request.lodLevel);
      this.queuedSet.delete(key);
      return request;
    }
    return undefined;
  }

  /**
   * Remove and return the highest priority request (first in queue).
   */
  shift(): QueuedRequest | undefined {
    const request = this.queue.shift();
    if (request) {
      const key = this.getRequestKey(request.gridKey, request.lodLevel);
      this.queuedSet.delete(key);
    }
    return request;
  }

  /**
   * Get the current queue length.
   */
  get length(): number {
    return this.queue.length;
  }

  /**
   * Clear all requests from the queue.
   */
  clear(): void {
    this.queue = [];
    this.queuedSet.clear();
  }
}

=== src/terrain/EdgeStitcher.spec.ts ===
import { describe, it, expect, beforeEach } from 'vitest';
import {
  calculateStepRatio,
  getResolutionForLevel,
  getVertexIndex,
  generateGridIndices,
  isOnEdge,
  computeStitchedIndices,
  clearStitchCache,
  getStitchCacheSize,
} from './EdgeStitcher';
import type { NeighborLods } from './LodUtils';

describe(calculateStepRatio.name, () => {
  it.each([
    { myRes: 512, neighborRes: 512, expected: 1 },
    { myRes: 512, neighborRes: 256, expected: 2 },
    { myRes: 512, neighborRes: 128, expected: 4 },
    { myRes: 512, neighborRes: 64, expected: 8 },
    { myRes: 256, neighborRes: 128, expected: 2 },
    { myRes: 256, neighborRes: 64, expected: 4 },
    { myRes: 128, neighborRes: 64, expected: 2 },
  ])('returns $expected for myRes=$myRes, neighborRes=$neighborRes', 
    ({ myRes, neighborRes, expected }) => {
      expect(calculateStepRatio(myRes, neighborRes)).toBe(expected);
    }
  );

  it('returns 1 when neighbor has higher resolution', () => {
    expect(calculateStepRatio(128, 256)).toBe(1);
    expect(calculateStepRatio(64, 512)).toBe(1);
  });

  it('returns 1 when neighbor resolution is 0 or negative', () => {
    expect(calculateStepRatio(512, 0)).toBe(1);
    expect(calculateStepRatio(512, -1)).toBe(1);
  });
});

describe(getResolutionForLevel.name, () => {
  const lodLevels = [512, 256, 128, 64];

  it.each([
    { level: 0, expected: 512 },
    { level: 1, expected: 256 },
    { level: 2, expected: 128 },
    { level: 3, expected: 64 },
  ])('returns $expected for level $level', ({ level, expected }) => {
    expect(getResolutionForLevel(level, lodLevels)).toBe(expected);
  });

  it('returns first level for negative index', () => {
    expect(getResolutionForLevel(-1, lodLevels)).toBe(512);
  });

  it('returns first level for index beyond array', () => {
    expect(getResolutionForLevel(10, lodLevels)).toBe(512);
  });
});

describe(getVertexIndex.name, () => {
  it('returns correct index for origin', () => {
    expect(getVertexIndex(0, 0, 4)).toBe(0);
  });

  it('returns correct index for end of first row', () => {
    // Resolution 4 means 5 vertices per row (0,1,2,3,4)
    expect(getVertexIndex(4, 0, 4)).toBe(4);
  });

  it('returns correct index for start of second row', () => {
    // Resolution 4 means 5 vertices per row
    expect(getVertexIndex(0, 1, 4)).toBe(5);
  });

  it('returns correct index for last vertex', () => {
    // 4x4 grid has 5x5=25 vertices, last is at (4,4) = index 24
    expect(getVertexIndex(4, 4, 4)).toBe(24);
  });

  it('calculates index correctly for larger grid', () => {
    // Resolution 128 means 129 vertices per row
    expect(getVertexIndex(0, 1, 128)).toBe(129);
    expect(getVertexIndex(128, 0, 128)).toBe(128);
    expect(getVertexIndex(128, 128, 128)).toBe(129 * 129 - 1);
  });
});

describe(generateGridIndices.name, () => {
  it('generates correct number of indices for small grid', () => {
    const indices = generateGridIndices(2);
    // 2x2 grid = 4 quads = 8 triangles = 24 indices
    expect(indices.length).toBe(2 * 2 * 2 * 3);
  });

  it('generates correct number of indices for larger grid', () => {
    const indices = generateGridIndices(4);
    // 4x4 grid = 16 quads = 32 triangles = 96 indices
    expect(indices.length).toBe(4 * 4 * 2 * 3);
  });

  it('generates valid vertex references', () => {
    const resolution = 4;
    const indices = generateGridIndices(resolution);
    const maxVertexIndex = (resolution + 1) * (resolution + 1) - 1;
    
    for (const idx of indices) {
      expect(idx).toBeGreaterThanOrEqual(0);
      expect(idx).toBeLessThanOrEqual(maxVertexIndex);
    }
  });

  it('generates indices in groups of 3 (triangles)', () => {
    const indices = generateGridIndices(4);
    expect(indices.length % 3).toBe(0);
  });
});

describe(isOnEdge.name, () => {
  const resolution = 4;

  it.each([
    { x: 0, z: 0, edge: 'north' as const, expected: true },
    { x: 2, z: 0, edge: 'north' as const, expected: true },
    { x: 4, z: 0, edge: 'north' as const, expected: true },
    { x: 0, z: 1, edge: 'north' as const, expected: false },
  ])('north edge: ($x,$z) is $expected', ({ x, z, edge, expected }) => {
    expect(isOnEdge(x, z, resolution, edge)).toBe(expected);
  });

  it.each([
    { x: 0, z: 4, edge: 'south' as const, expected: true },
    { x: 2, z: 4, edge: 'south' as const, expected: true },
    { x: 0, z: 3, edge: 'south' as const, expected: false },
  ])('south edge: ($x,$z) is $expected', ({ x, z, edge, expected }) => {
    expect(isOnEdge(x, z, resolution, edge)).toBe(expected);
  });

  it.each([
    { x: 0, z: 0, edge: 'west' as const, expected: true },
    { x: 0, z: 2, edge: 'west' as const, expected: true },
    { x: 1, z: 0, edge: 'west' as const, expected: false },
  ])('west edge: ($x,$z) is $expected', ({ x, z, edge, expected }) => {
    expect(isOnEdge(x, z, resolution, edge)).toBe(expected);
  });

  it.each([
    { x: 4, z: 0, edge: 'east' as const, expected: true },
    { x: 4, z: 2, edge: 'east' as const, expected: true },
    { x: 3, z: 0, edge: 'east' as const, expected: false },
  ])('east edge: ($x,$z) is $expected', ({ x, z, edge, expected }) => {
    expect(isOnEdge(x, z, resolution, edge)).toBe(expected);
  });
});

describe(computeStitchedIndices.name, () => {
  beforeEach(() => {
    clearStitchCache();
  });

  describe('when all neighbors have same LOD', () => {
    it('returns standard grid indices', () => {
      const neighborLods: NeighborLods = { north: 0, south: 0, east: 0, west: 0 };
      const indices = computeStitchedIndices(4, neighborLods, 0, [4, 2, 1]);
      const standardIndices = generateGridIndices(4);
      
      expect(indices.length).toBe(standardIndices.length);
    });
  });

  describe('when one neighbor has lower LOD', () => {
    it('generates valid indices with north neighbor lower', () => {
      // Use small resolution for easier testing
      const neighborLods: NeighborLods = { north: 1, south: 0, east: 0, west: 0 };
      const indices = computeStitchedIndices(4, neighborLods, 0, [4, 2, 1]);
      
      // Should have valid indices
      expect(indices.length).toBeGreaterThan(0);
      expect(indices.length % 3).toBe(0);
      
      // All indices should be valid vertex references
      const maxVertexIndex = 5 * 5 - 1; // (4+1)^2 - 1
      for (const idx of indices) {
        expect(idx).toBeGreaterThanOrEqual(0);
        expect(idx).toBeLessThanOrEqual(maxVertexIndex);
      }
    });

    it('generates valid indices with south neighbor lower', () => {
      const neighborLods: NeighborLods = { north: 0, south: 1, east: 0, west: 0 };
      const indices = computeStitchedIndices(4, neighborLods, 0, [4, 2, 1]);
      
      expect(indices.length).toBeGreaterThan(0);
      expect(indices.length % 3).toBe(0);
    });

    it('generates valid indices with east neighbor lower', () => {
      const neighborLods: NeighborLods = { north: 0, south: 0, east: 1, west: 0 };
      const indices = computeStitchedIndices(4, neighborLods, 0, [4, 2, 1]);
      
      expect(indices.length).toBeGreaterThan(0);
      expect(indices.length % 3).toBe(0);
    });

    it('generates valid indices with west neighbor lower', () => {
      const neighborLods: NeighborLods = { north: 0, south: 0, east: 0, west: 1 };
      const indices = computeStitchedIndices(4, neighborLods, 0, [4, 2, 1]);
      
      expect(indices.length).toBeGreaterThan(0);
      expect(indices.length % 3).toBe(0);
    });
  });

  describe('when multiple neighbors have lower LOD', () => {
    it('generates valid indices with two adjacent lower neighbors', () => {
      const neighborLods: NeighborLods = { north: 1, south: 0, east: 1, west: 0 };
      const indices = computeStitchedIndices(4, neighborLods, 0, [4, 2, 1]);
      
      expect(indices.length).toBeGreaterThan(0);
      expect(indices.length % 3).toBe(0);
    });

    it('generates valid indices with all neighbors lower', () => {
      const neighborLods: NeighborLods = { north: 1, south: 1, east: 1, west: 1 };
      const indices = computeStitchedIndices(4, neighborLods, 0, [4, 2, 1]);
      
      expect(indices.length).toBeGreaterThan(0);
      expect(indices.length % 3).toBe(0);
    });
  });

  describe('caching', () => {
    it('caches results for identical configurations', () => {
      const neighborLods: NeighborLods = { north: 1, south: 0, east: 0, west: 0 };
      
      const indices1 = computeStitchedIndices(4, neighborLods, 0, [4, 2, 1]);
      const indices2 = computeStitchedIndices(4, neighborLods, 0, [4, 2, 1]);
      
      // Should be the same array reference (cached)
      expect(indices1).toBe(indices2);
      expect(getStitchCacheSize()).toBe(1);
    });

    it('creates separate cache entries for different configurations', () => {
      const neighborLods1: NeighborLods = { north: 1, south: 0, east: 0, west: 0 };
      const neighborLods2: NeighborLods = { north: 0, south: 1, east: 0, west: 0 };
      
      computeStitchedIndices(4, neighborLods1, 0, [4, 2, 1]);
      computeStitchedIndices(4, neighborLods2, 0, [4, 2, 1]);
      
      expect(getStitchCacheSize()).toBe(2);
    });
  });

  describe('with realistic LOD levels', () => {
    it('handles 512/256 transition', () => {
      // Simulating a chunk at LOD 0 (512) next to a chunk at LOD 1 (256)
      const neighborLods: NeighborLods = { north: 1, south: 0, east: 0, west: 0 };
      const indices = computeStitchedIndices(8, neighborLods, 0, [8, 4, 2, 1]);
      
      expect(indices.length).toBeGreaterThan(0);
      expect(indices.length % 3).toBe(0);
    });
  });

  describe('edge nearest-neighbor structure', () => {
    it('generates nearest-neighbor pattern for north edge', () => {
      // Resolution 4, north neighbor has stepRatio 2
      // Snapped edge vertices at x=0, 2, 4 (indices 0, 2, 4)
      const neighborLods: NeighborLods = { north: 1, south: 0, east: 0, west: 0 };
      const indices = computeStitchedIndices(4, neighborLods, 0, [4, 2, 1]);
      
      // Extract triangles (groups of 3)
      const triangles: number[][] = [];
      for (let i = 0; i < indices.length; i += 3) {
        triangles.push([indices[i], indices[i + 1], indices[i + 2]]);
      }
      
      // North edge vertices are at z=0: indices 0, 1, 2, 3, 4
      // Interior vertices are at z=1: indices 5, 6, 7, 8, 9
      const northEdgeVertices = new Set([0, 1, 2, 3, 4]);
      
      // Find triangles that touch the north edge (contain a north edge vertex)
      const northEdgeTriangles = triangles.filter(tri => 
        tri.some(v => northEdgeVertices.has(v))
      );
      
      // With stepRatio=2, snapped positions are at x=0, 2, 4
      // Interior vertices at x=0,1 should snap to edge x=0 (index 0)
      // Interior vertices at x=2,3 should snap to edge x=2 (index 2)
      // Interior vertices at x=4 should snap to edge x=4 (index 4)
      const snappedEdgeVertices = new Set([0, 2, 4]); // x=0, x=2, x=4
      
      // Verify nearest-neighbor: each triangle should connect to a snapped edge vertex
      for (const tri of northEdgeTriangles) {
        const hasSnappedEdge = tri.some(v => snappedEdgeVertices.has(v));
        expect(hasSnappedEdge).toBe(true);
      }
      
      // Verify triangles connect interior vertices to their nearest snapped edge
      // Interior x=0,1 (indices 5,6) should connect to edge x=0 (index 0)
      const trianglesWithEdge0 = northEdgeTriangles.filter(tri => tri.includes(0));
      // Interior vertices 5,6 should connect to edge 0
      expect(trianglesWithEdge0.length).toBeGreaterThan(0);
      
      // All triangles should be valid (no duplicate vertices in same triangle)
      for (const tri of triangles) {
        expect(new Set(tri).size).toBe(3); // All 3 vertices should be unique
      }
    });

    it('generates nearest-neighbor pattern for all edges', () => {
      // Test all four edges with lower LOD neighbors
      const testCases: Array<{ neighborLods: NeighborLods; description: string }> = [
        { neighborLods: { north: 1, south: 0, east: 0, west: 0 }, description: 'north' },
        { neighborLods: { north: 0, south: 1, east: 0, west: 0 }, description: 'south' },
        { neighborLods: { north: 0, south: 0, east: 1, west: 0 }, description: 'east' },
        { neighborLods: { north: 0, south: 0, east: 0, west: 1 }, description: 'west' },
      ];
      
      for (const { neighborLods } of testCases) {
        const indices = computeStitchedIndices(4, neighborLods, 0, [4, 2, 1]);
        
        // Extract triangles
        const triangles: number[][] = [];
        for (let i = 0; i < indices.length; i += 3) {
          triangles.push([indices[i], indices[i + 1], indices[i + 2]]);
        }
        
        // Verify all triangles are valid (no degenerate triangles)
        for (const tri of triangles) {
          expect(new Set(tri).size).toBe(3); // All vertices unique
          expect(tri.every(v => v >= 0 && v < 25)).toBe(true); // Valid vertex indices (5x5 grid)
        }
        
        // Should have generated triangles
        expect(triangles.length).toBeGreaterThan(0);
        
        // With stepRatio=2, snapped positions should be at multiples of 2
        // Verify that edge triangles connect to snapped vertices (not all fan from one point)
        // This is a basic sanity check - the detailed nearest-neighbor verification
        // is done in the specific edge test above
      }
    });
  });
});

describe('clearStitchCache', () => {
  it('clears all cached entries', () => {
    const neighborLods: NeighborLods = { north: 1, south: 0, east: 0, west: 0 };
    computeStitchedIndices(4, neighborLods, 0, [4, 2, 1]);
    
    expect(getStitchCacheSize()).toBeGreaterThan(0);
    
    clearStitchCache();
    
    expect(getStitchCacheSize()).toBe(0);
  });
});

=== src/terrain/EdgeStitcher.ts ===
/**
 * Edge stitching utility for LOD terrain
 * 
 * When adjacent chunks have different LOD levels, gaps can appear at the edges.
 * This module modifies the index buffer of higher-resolution chunks to "drop" 
 * vertices along edges to match the lower-resolution neighbor.
 * 
 * Example: If chunk A (512 res) borders chunk B (128 res):
 * - A has vertices every (width/512) units
 * - B has vertices every (width/128) units = 4x spacing
 * - We modify A's triangles along that edge to skip 3 out of every 4 vertices
 */

import type { NeighborLods, CardinalDirection } from './LodUtils';

// Simple LRU cache for stitched indices
const stitchCache: Map<string, Uint32Array> = new Map();
const MAX_CACHE_SIZE = 256;

/**
 * Generate a cache key for a specific stitching configuration
 */
function getCacheKey(
  resolution: number,
  neighborLods: NeighborLods,
  myLodLevel: number
): string {
  return `${resolution}:${myLodLevel}:${neighborLods.north}:${neighborLods.south}:${neighborLods.east}:${neighborLods.west}`;
}

/**
 * Calculate the step ratio between two LOD levels.
 * Returns how many vertices to skip on the higher-res side.
 * 
 * @param myResolution - Resolution of this chunk
 * @param neighborResolution - Resolution of the neighbor chunk
 * @returns Step ratio (1 = same, 2 = skip every other, 4 = skip 3 of 4, etc.)
 */
export function calculateStepRatio(
  myResolution: number,
  neighborResolution: number
): number {
  if (neighborResolution >= myResolution || neighborResolution <= 0) {
    return 1; // No stitching needed - neighbor is same or higher resolution
  }
  return Math.round(myResolution / neighborResolution);
}

/**
 * Get the resolution for a given LOD level
 */
export function getResolutionForLevel(
  lodLevel: number,
  lodLevels: readonly number[]
): number {
  if (lodLevel < 0 || lodLevel >= lodLevels.length) {
    return lodLevels[0] ?? 512;
  }
  return lodLevels[lodLevel];
}

/**
 * Get vertex index in the grid for position (x, z)
 * PlaneGeometry generates vertices row by row (x varies fastest)
 * 
 * @param x - Column index (0 to resolution)
 * @param z - Row index (0 to resolution)
 * @param resolution - Number of segments (vertices = resolution + 1)
 */
export function getVertexIndex(x: number, z: number, resolution: number): number {
  const verticesPerRow = resolution + 1;
  return z * verticesPerRow + x;
}

/**
 * Generate standard grid indices for a PlaneGeometry
 * This creates two triangles per cell in the grid.
 * 
 * @param resolution - Number of segments per side
 * @returns Uint32Array of triangle indices
 */
export function generateGridIndices(resolution: number): Uint32Array {
  const triangleCount = resolution * resolution * 2;
  const indices = new Uint32Array(triangleCount * 3);
  
  let idx = 0;
  for (let z = 0; z < resolution; z++) {
    for (let x = 0; x < resolution; x++) {
      const a = getVertexIndex(x, z, resolution);
      const b = getVertexIndex(x + 1, z, resolution);
      const c = getVertexIndex(x, z + 1, resolution);
      const d = getVertexIndex(x + 1, z + 1, resolution);

      // Two triangles per quad
      // Triangle 1: a, c, b
      indices[idx++] = a;
      indices[idx++] = c;
      indices[idx++] = b;
      
      // Triangle 2: b, c, d
      indices[idx++] = b;
      indices[idx++] = c;
      indices[idx++] = d;
    }
  }

  return indices;
}

/**
 * Check if a vertex is on a specific edge of the grid
 */
export function isOnEdge(
  x: number,
  z: number,
  resolution: number,
  edge: CardinalDirection
): boolean {
  switch (edge) {
    case 'north': return z === 0;
    case 'south': return z === resolution;
    case 'west': return x === 0;
    case 'east': return x === resolution;
  }
}

/**
 * Compute stitched indices for a chunk that needs to match lower-resolution neighbors.
 * 
 * The strategy is:
 * 1. Generate standard grid indices
 * 2. For each edge where neighbor has lower LOD:
 *    - Rebuild triangles along that edge to use fewer vertices
 *    - Creates "fan" triangles from interior to snapped edge vertices
 * 
 * @param resolution - Number of segments per side (e.g., 512)
 * @param neighborLods - LOD levels of cardinal neighbors
 * @param myLodLevel - This chunk's LOD level
 * @param lodLevels - Array mapping LOD level to resolution
 * @returns Uint32Array of stitched triangle indices
 */
export function computeStitchedIndices(
  resolution: number,
  neighborLods: NeighborLods,
  myLodLevel: number,
  lodLevels: readonly number[]
): Uint32Array {
  // Check cache first
  const cacheKey = getCacheKey(resolution, neighborLods, myLodLevel);
  const cached = stitchCache.get(cacheKey);
  if (cached) {
    return cached;
  }

  const myResolution = getResolutionForLevel(myLodLevel, lodLevels);
  
  // Calculate step ratios for each edge
  const stepRatios: Record<CardinalDirection, number> = {
    north: calculateStepRatio(myResolution, getResolutionForLevel(neighborLods.north, lodLevels)),
    south: calculateStepRatio(myResolution, getResolutionForLevel(neighborLods.south, lodLevels)),
    east: calculateStepRatio(myResolution, getResolutionForLevel(neighborLods.east, lodLevels)),
    west: calculateStepRatio(myResolution, getResolutionForLevel(neighborLods.west, lodLevels)),
  };

  // If no stitching needed (all neighbors same or higher res), return standard indices
  if (stepRatios.north === 1 && stepRatios.south === 1 && 
      stepRatios.east === 1 && stepRatios.west === 1) {
    const standardIndices = generateGridIndices(resolution);
    cacheToMap(cacheKey, standardIndices);
    return standardIndices;
  }

  // Build indices with edge stitching
  const indices = buildStitchedIndices(resolution, stepRatios);
  
  // Cache the result
  cacheToMap(cacheKey, indices);
  
  return indices;
}

/**
 * Build index buffer with stitched edges.
 * 
 * For edges that need stitching, we:
 * 1. Skip the edge cells in the standard grid generation
 * 2. Create "fan" triangles that connect interior vertices to snapped edge vertices
 */
function buildStitchedIndices(
  resolution: number,
  stepRatios: Record<CardinalDirection, number>
): Uint32Array {
  const indices: number[] = [];

  // Generate interior quads (not touching any edge that needs stitching)
  for (let z = 0; z < resolution; z++) {
    for (let x = 0; x < resolution; x++) {
      const touchesNorth = z === 0 && stepRatios.north > 1;
      const touchesSouth = z === resolution - 1 && stepRatios.south > 1;
      const touchesWest = x === 0 && stepRatios.west > 1;
      const touchesEast = x === resolution - 1 && stepRatios.east > 1;

      if (touchesNorth || touchesSouth || touchesWest || touchesEast) {
        // Skip - will be handled by edge stitching
        continue;
      }

      // Standard quad (two triangles)
      const a = getVertexIndex(x, z, resolution);
      const b = getVertexIndex(x + 1, z, resolution);
      const c = getVertexIndex(x, z + 1, resolution);
      const d = getVertexIndex(x + 1, z + 1, resolution);

      indices.push(a, c, b);
      indices.push(b, c, d);
    }
  }

  // Generate stitched edge triangles
  if (stepRatios.north > 1) {
    generateStitchedEdge(indices, resolution, 'north', stepRatios.north, stepRatios);
  }
  if (stepRatios.south > 1) {
    generateStitchedEdge(indices, resolution, 'south', stepRatios.south, stepRatios);
  }
  if (stepRatios.west > 1) {
    generateStitchedEdge(indices, resolution, 'west', stepRatios.west, stepRatios);
  }
  if (stepRatios.east > 1) {
    generateStitchedEdge(indices, resolution, 'east', stepRatios.east, stepRatios);
  }

  return new Uint32Array(indices);
}

/**
 * Get the nearest snapped position for a given coordinate.
 * Snaps to the nearest multiple of stepRatio.
 * 
 * @param pos - Position coordinate (0 to resolution)
 * @param stepRatio - Step ratio for snapping
 * @returns Nearest snapped position
 */
function getNearestSnappedPosition(pos: number, stepRatio: number): number {
  return Math.round(pos / stepRatio) * stepRatio;
}

/**
 * Generate stitched triangles for one edge.
 * Creates triangles connecting interior row to nearest snapped edge vertices.
 */
function generateStitchedEdge(
  indices: number[],
  resolution: number,
  edge: CardinalDirection,
  stepRatio: number,
  allStepRatios: Record<CardinalDirection, number>
): void {
  switch (edge) {
    case 'north':
      generateNorthEdgeNearestNeighbor(indices, resolution, stepRatio, allStepRatios);
      break;
    case 'south':
      generateSouthEdgeNearestNeighbor(indices, resolution, stepRatio, allStepRatios);
      break;
    case 'west':
      generateWestEdgeNearestNeighbor(indices, resolution, stepRatio, allStepRatios);
      break;
    case 'east':
      generateEastEdgeNearestNeighbor(indices, resolution, stepRatio, allStepRatios);
      break;
  }
}

/**
 * Generate triangles for north edge (z=0) using nearest-neighbor snapping.
 * Each interior vertex connects to the nearest snapped edge vertex.
 */
function generateNorthEdgeNearestNeighbor(
  indices: number[],
  resolution: number,
  stepRatio: number,
  _allStepRatios: Record<CardinalDirection, number>
): void {
  // Process each interior edge segment (x, x+1)
  for (let x = 0; x < resolution; x++) {
    const interiorLeft = getVertexIndex(x, 1, resolution);
    const interiorRight = getVertexIndex(x + 1, 1, resolution);
    
    // Find nearest snapped edge vertices
    const snapLeft = getNearestSnappedPosition(x, stepRatio);
    const snapRight = getNearestSnappedPosition(x + 1, stepRatio);
    
    const edgeLeft = getVertexIndex(snapLeft, 0, resolution);
    const edgeRight = getVertexIndex(snapRight, 0, resolution);
    
    if (snapLeft === snapRight) {
      // Both interior vertices snap to the same edge vertex - one triangle
      indices.push(edgeLeft, interiorLeft, interiorRight);
    } else {
      // Transition point - two triangles
      // Triangle 1: edgeLeft to interiorLeft to interiorRight (CCW)
      indices.push(edgeLeft, interiorLeft, interiorRight);
      // Triangle 2: edgeLeft to interiorRight to edgeRight (CCW)
      indices.push(edgeLeft, interiorRight, edgeRight);
    }
  }
}

/**
 * Generate triangles for south edge (z=resolution) using nearest-neighbor snapping.
 * Each interior vertex connects to the nearest snapped edge vertex.
 * South edge needs reversed winding for CCW (interior is above edge).
 */
function generateSouthEdgeNearestNeighbor(
  indices: number[],
  resolution: number,
  stepRatio: number,
  _allStepRatios: Record<CardinalDirection, number>
): void {
  // Process each interior edge segment (x, x+1)
  for (let x = 0; x < resolution; x++) {
    const interiorLeft = getVertexIndex(x, resolution - 1, resolution);
    const interiorRight = getVertexIndex(x + 1, resolution - 1, resolution);
    
    // Find nearest snapped edge vertices
    const snapLeft = getNearestSnappedPosition(x, stepRatio);
    const snapRight = getNearestSnappedPosition(x + 1, stepRatio);
    
    const edgeLeft = getVertexIndex(snapLeft, resolution, resolution);
    const edgeRight = getVertexIndex(snapRight, resolution, resolution);
    
    if (snapLeft === snapRight) {
      // Both interior vertices snap to the same edge vertex - one triangle (CCW winding)
      indices.push(interiorLeft, edgeLeft, interiorRight);
    } else {
      // Transition point - two triangles (CCW winding)
      // Triangle 1: interiorLeft to edgeLeft to interiorRight
      indices.push(interiorLeft, edgeLeft, interiorRight);
      // Triangle 2: interiorRight to edgeLeft to edgeRight
      indices.push(interiorRight, edgeLeft, edgeRight);
    }
  }
}

/**
 * Generate triangles for west edge (x=0) using nearest-neighbor snapping.
 * Each interior vertex connects to the nearest snapped edge vertex.
 */
function generateWestEdgeNearestNeighbor(
  indices: number[],
  resolution: number,
  stepRatio: number,
  _allStepRatios: Record<CardinalDirection, number>
): void {
  // Process each interior edge segment (z, z+1)
  for (let z = 0; z < resolution; z++) {
    const interiorTop = getVertexIndex(1, z, resolution);
    const interiorBottom = getVertexIndex(1, z + 1, resolution);
    
    // Find nearest snapped edge vertices
    const snapTop = getNearestSnappedPosition(z, stepRatio);
    const snapBottom = getNearestSnappedPosition(z + 1, stepRatio);
    
    const edgeTop = getVertexIndex(0, snapTop, resolution);
    const edgeBottom = getVertexIndex(0, snapBottom, resolution);
    
    if (snapTop === snapBottom) {
      // Both interior vertices snap to the same edge vertex - one triangle (CCW winding)
      indices.push(edgeTop, interiorBottom, interiorTop);
    } else {
      // Transition point - two triangles (CCW winding)
      // Triangle 1: edgeTop to interiorBottom to interiorTop
      indices.push(edgeTop, interiorBottom, interiorTop);
      // Triangle 2: edgeTop to edgeBottom to interiorBottom
      indices.push(edgeTop, edgeBottom, interiorBottom);
    }
  }
}

/**
 * Generate triangles for east edge (x=resolution) using nearest-neighbor snapping.
 * Each interior vertex connects to the nearest snapped edge vertex.
 */
function generateEastEdgeNearestNeighbor(
  indices: number[],
  resolution: number,
  stepRatio: number,
  _allStepRatios: Record<CardinalDirection, number>
): void {
  // Process each interior edge segment (z, z+1)
  for (let z = 0; z < resolution; z++) {
    const interiorTop = getVertexIndex(resolution - 1, z, resolution);
    const interiorBottom = getVertexIndex(resolution - 1, z + 1, resolution);
    
    // Find nearest snapped edge vertices
    const snapTop = getNearestSnappedPosition(z, stepRatio);
    const snapBottom = getNearestSnappedPosition(z + 1, stepRatio);
    
    const edgeTop = getVertexIndex(resolution, snapTop, resolution);
    const edgeBottom = getVertexIndex(resolution, snapBottom, resolution);
    
    if (snapTop === snapBottom) {
      // Both interior vertices snap to the same edge vertex - one triangle (CCW winding)
      indices.push(edgeTop, interiorTop, interiorBottom);
    } else {
      // Transition point - two triangles (CCW winding)
      // Triangle 1: edgeTop to interiorTop to interiorBottom
      indices.push(edgeTop, interiorTop, interiorBottom);
      // Triangle 2: edgeTop to interiorBottom to edgeBottom
      indices.push(edgeTop, interiorBottom, edgeBottom);
    }
  }
}

/**
 * Add to cache with LRU eviction
 */
function cacheToMap(key: string, indices: Uint32Array): void {
  if (stitchCache.size >= MAX_CACHE_SIZE) {
    // Remove oldest entry (first key in Map)
    const firstKey = stitchCache.keys().next().value;
    if (firstKey) {
      stitchCache.delete(firstKey);
    }
  }
  stitchCache.set(key, indices);
}

/**
 * Clear the stitch cache (useful for testing)
 */
export function clearStitchCache(): void {
  stitchCache.clear();
}

/**
 * Get the current cache size (useful for testing/debugging)
 */
export function getStitchCacheSize(): number {
  return stitchCache.size;
}

=== src/terrain/LodUtils.spec.ts ===
import { describe, it, expect } from 'vitest';
import {
  getLodLevelForDistance,
  getResolutionForLodLevel,
  getNeighborKeys,
  parseGridKey,
  createGridKey,
  getChunkWorldCenter,
  getDistanceToChunk,
  LodDetailLevel,
  getTriangleEdgeLength,
  projectToScreenSpace,
  getLodLevelForScreenSize,
} from './LodUtils';

describe(getLodLevelForDistance.name, () => {
  const lodDistances = [0, 100, 200, 400];

  it.each([
    { distance: 0, expected: 0 },
    { distance: 50, expected: 0 },
    { distance: 99, expected: 0 },
    { distance: 100, expected: 1 },
    { distance: 150, expected: 1 },
    { distance: 199, expected: 1 },
    { distance: 200, expected: 2 },
    { distance: 300, expected: 2 },
    { distance: 400, expected: 3 },
    { distance: 1000, expected: 3 },
  ])('returns $expected for distance $distance', ({ distance, expected }) => {
    expect(getLodLevelForDistance(distance, lodDistances)).toBe(expected);
  });

  it('returns 0 for negative distance', () => {
    expect(getLodLevelForDistance(-50, lodDistances)).toBe(0);
  });

  it('returns 0 for empty lodDistances array', () => {
    expect(getLodLevelForDistance(100, [])).toBe(0);
  });

  it('handles single LOD level', () => {
    expect(getLodLevelForDistance(0, [0])).toBe(0);
    expect(getLodLevelForDistance(500, [0])).toBe(0);
  });
});

describe(getResolutionForLodLevel.name, () => {
  const lodLevels = [512, 256, 128, 64];

  it.each([
    { lodIndex: 0, expected: 512 },
    { lodIndex: 1, expected: 256 },
    { lodIndex: 2, expected: 128 },
    { lodIndex: 3, expected: 64 },
  ])('returns $expected for lodIndex $lodIndex', ({ lodIndex, expected }) => {
    expect(getResolutionForLodLevel(lodIndex, lodLevels)).toBe(expected);
  });

  it('returns first level for negative index', () => {
    expect(getResolutionForLodLevel(-1, lodLevels)).toBe(512);
  });

  it('returns last level for index beyond array', () => {
    expect(getResolutionForLodLevel(10, lodLevels)).toBe(64);
  });

  it('returns default for empty array', () => {
    expect(getResolutionForLodLevel(0, [])).toBe(512);
  });
});

describe(getNeighborKeys.name, () => {
  it('returns correct neighbor keys for origin chunk', () => {
    const neighbors = getNeighborKeys(0, 0);

    expect(neighbors.north).toBe('0,-1');
    expect(neighbors.south).toBe('0,1');
    expect(neighbors.east).toBe('1,0');
    expect(neighbors.west).toBe('-1,0');
  });

  it('returns correct neighbor keys for positive coordinates', () => {
    const neighbors = getNeighborKeys(5, 3);

    expect(neighbors.north).toBe('5,2');
    expect(neighbors.south).toBe('5,4');
    expect(neighbors.east).toBe('6,3');
    expect(neighbors.west).toBe('4,3');
  });

  it('returns correct neighbor keys for negative coordinates', () => {
    const neighbors = getNeighborKeys(-2, -3);

    expect(neighbors.north).toBe('-2,-4');
    expect(neighbors.south).toBe('-2,-2');
    expect(neighbors.east).toBe('-1,-3');
    expect(neighbors.west).toBe('-3,-3');
  });
});

describe(parseGridKey.name, () => {
  it.each([
    { key: '0,0', expected: [0, 0] },
    { key: '5,3', expected: [5, 3] },
    { key: '-2,-3', expected: [-2, -3] },
    { key: '100,-50', expected: [100, -50] },
  ])('parses "$key" to $expected', ({ key, expected }) => {
    expect(parseGridKey(key)).toEqual(expected);
  });
});

describe(createGridKey.name, () => {
  it.each([
    { x: 0, z: 0, expected: '0,0' },
    { x: 5, z: 3, expected: '5,3' },
    { x: -2, z: -3, expected: '-2,-3' },
  ])('creates "$expected" from ($x, $z)', ({ x, z, expected }) => {
    expect(createGridKey(x, z)).toBe(expected);
  });
});

describe(getChunkWorldCenter.name, () => {
  const chunkWidth = 50;
  const chunkDepth = 50;
  // Chunks are CENTERED at gridX * chunkWidth, gridZ * chunkDepth

  it('returns correct center for origin chunk', () => {
    // Chunk (0,0) is centered at (0, 0)
    const center = getChunkWorldCenter(0, 0, chunkWidth, chunkDepth);

    expect(center.x).toBe(0);
    expect(center.z).toBe(0);
  });

  it('returns correct center for chunk at (1, 1)', () => {
    // Chunk (1,1) is centered at (50, 50)
    const center = getChunkWorldCenter(1, 1, chunkWidth, chunkDepth);

    expect(center.x).toBe(50);
    expect(center.z).toBe(50);
  });

  it('returns correct center for negative coordinates', () => {
    // Chunk (-1,-1) is centered at (-50, -50)
    const center = getChunkWorldCenter(-1, -1, chunkWidth, chunkDepth);

    expect(center.x).toBe(-50);
    expect(center.z).toBe(-50);
  });

  it('handles non-square chunks', () => {
    // Chunk (0,0) with 100x50 dimensions is centered at (0, 0)
    const center = getChunkWorldCenter(0, 0, 100, 50);

    expect(center.x).toBe(0);
    expect(center.z).toBe(0);
  });
});

describe(getDistanceToChunk.name, () => {
  const chunkWidth = 50;
  const chunkDepth = 50;
  // Chunk (0,0) is CENTERED at origin, so bounds are X=[-25, 25], Z=[-25, 25]

  it('returns 0 when point is on chunk plane at ground level', () => {
    // Chunk (0,0) bounds: X=[-25, 25], Z=[-25, 25] (centered)
    // Point at (0, 0, 0) is at chunk center on ground, nearest point is itself
    const distance = getDistanceToChunk(0, 0, 0, 0, 0, chunkWidth, chunkDepth);
    expect(distance).toBe(0);
  });

  it('returns Y distance when point is directly above chunk center', () => {
    // Chunk (0,0) bounds: X=[-25, 25], Z=[-25, 25] (centered)
    // Point at (0, 50, 0) projects to (0, 0, 0) on chunk plane
    // Distance = sqrt(0 + 50^2 + 0) = 50
    const distance = getDistanceToChunk(0, 50, 0, 0, 0, chunkWidth, chunkDepth);
    expect(distance).toBe(50);
  });

  it('returns 3D distance to nearest edge when point is outside chunk', () => {
    // Chunk (0,0) bounds: X=[-25, 25], Z=[-25, 25] (centered)
    // Point at (0, 10, 50) is outside on Z axis (Z > 25)
    // Projects to (0, 0, 25) - the south edge
    // Distance = sqrt((0-0)^2 + (10-0)^2 + (50-25)^2) = sqrt(0 + 100 + 625) = sqrt(725) ≈ 26.93
    const distance = getDistanceToChunk(0, 10, 50, 0, 0, chunkWidth, chunkDepth);
    expect(distance).toBeCloseTo(Math.sqrt(725), 5);
  });

  it('returns 3D distance to nearest corner when point is diagonally outside', () => {
    // Chunk (0,0) bounds: X=[-25, 25], Z=[-25, 25] (centered)
    // Point at (50, 20, 50) is outside on both axes
    // Projects to corner (25, 0, 25)
    // Distance = sqrt((50-25)^2 + (20-0)^2 + (50-25)^2) = sqrt(625 + 400 + 625) = sqrt(1650) ≈ 40.62
    const distance = getDistanceToChunk(50, 20, 50, 0, 0, chunkWidth, chunkDepth);
    expect(distance).toBeCloseTo(Math.sqrt(1650), 5);
  });

  it('returns Y distance when point is at chunk edge horizontally', () => {
    // Chunk (0,0) bounds: X=[-25, 25], Z=[-25, 25] (centered)
    // Point at (25, 10, 0) is on east edge, projects to (25, 0, 0)
    // Distance = sqrt((25-25)^2 + (10-0)^2 + (0-0)^2) = 10
    const distance = getDistanceToChunk(25, 10, 0, 0, 0, chunkWidth, chunkDepth);
    expect(distance).toBe(10);
  });

  it('returns Y distance when point is inside chunk horizontally', () => {
    // Chunk (0,0) bounds: X=[-25, 25], Z=[-25, 25] (centered)
    // Point at (1, 5, 1) is inside chunk, projects to (1, 0, 1)
    // Distance = sqrt((1-1)^2 + (5-0)^2 + (1-1)^2) = 5
    const distance = getDistanceToChunk(1, 5, 1, 0, 0, chunkWidth, chunkDepth);
    expect(distance).toBe(5);
  });
});

// ============================================================================
// Screen-space LOD selection tests
// ============================================================================

describe('LodDetailLevel', () => {
  it('has correct values for each level', () => {
    expect(LodDetailLevel.Maximum).toBe(1);
    expect(LodDetailLevel.High).toBe(2);
    expect(LodDetailLevel.Balanced).toBe(4);
    expect(LodDetailLevel.Performance).toBe(8);
  });
});

describe(getTriangleEdgeLength.name, () => {
  it.each([
    { resolution: 512, chunkWidth: 50, expected: 50 / 511 },
    { resolution: 256, chunkWidth: 50, expected: 50 / 255 },
    { resolution: 128, chunkWidth: 50, expected: 50 / 127 },
    { resolution: 64, chunkWidth: 50, expected: 50 / 63 },
    { resolution: 2, chunkWidth: 100, expected: 100 },
  ])(
    'returns $expected for resolution=$resolution, chunkWidth=$chunkWidth',
    ({ resolution, chunkWidth, expected }) => {
      expect(getTriangleEdgeLength(resolution, chunkWidth)).toBeCloseTo(expected);
    }
  );

  it('handles edge case of resolution <= 1', () => {
    expect(getTriangleEdgeLength(1, 50)).toBe(50);
    expect(getTriangleEdgeLength(0, 50)).toBe(50);
  });
});

describe(projectToScreenSpace.name, () => {
  const fov70Radians = (70 * Math.PI) / 180;
  const screenHeight = 1080;

  it('returns larger screen size for closer objects', () => {
    const closeSize = projectToScreenSpace(1, 10, fov70Radians, screenHeight);
    const farSize = projectToScreenSpace(1, 100, fov70Radians, screenHeight);

    expect(closeSize).toBeGreaterThan(farSize);
  });

  it('returns larger screen size for larger world objects', () => {
    const smallSize = projectToScreenSpace(1, 100, fov70Radians, screenHeight);
    const largeSize = projectToScreenSpace(10, 100, fov70Radians, screenHeight);

    expect(largeSize).toBeGreaterThan(smallSize);
  });

  it('returns screen height for zero distance', () => {
    const size = projectToScreenSpace(1, 0, fov70Radians, screenHeight);
    expect(size).toBe(screenHeight);
  });

  it('scales with screen height', () => {
    const size1080 = projectToScreenSpace(1, 100, fov70Radians, 1080);
    const size720 = projectToScreenSpace(1, 100, fov70Radians, 720);

    expect(size1080 / size720).toBeCloseTo(1080 / 720);
  });

  it('applies terrain tilt factor', () => {
    // With tilt, projected size should be smaller (cos factor)
    const noTilt = projectToScreenSpace(1, 100, fov70Radians, screenHeight, 0);
    const withTilt = projectToScreenSpace(1, 100, fov70Radians, screenHeight, Math.PI / 12);

    expect(withTilt).toBeLessThan(noTilt);
    expect(withTilt / noTilt).toBeCloseTo(Math.cos(Math.PI / 12));
  });
});

describe(getLodLevelForScreenSize.name, () => {
  const lodLevels = [512, 256, 128, 64];
  const chunkWidth = 50;
  const fov70Radians = (70 * Math.PI) / 180;
  const screenHeight = 1080;

  it('returns higher LOD index (coarser detail) for farther distances', () => {
    // Traditional LOD: fine detail close, coarse detail far
    const closeLod = getLodLevelForScreenSize(
      10, lodLevels, chunkWidth, fov70Radians, screenHeight, LodDetailLevel.Balanced
    );
    const farLod = getLodLevelForScreenSize(
      500, lodLevels, chunkWidth, fov70Radians, screenHeight, LodDetailLevel.Balanced
    );

    // Far = coarser (higher index), close = finer (lower index)
    expect(farLod).toBeGreaterThanOrEqual(closeLod);
  });

  it('returns different LOD levels based on target pixel size', () => {
    // At a distance where triangles are moderately sized
    // Maximum (1px) target is easier to meet -> can use coarser LOD (higher index)
    // Performance (8px) target is harder to meet -> needs finer LOD (lower index)
    const maxDetail = getLodLevelForScreenSize(
      300, lodLevels, chunkWidth, fov70Radians, screenHeight, LodDetailLevel.Maximum
    );
    const perfDetail = getLodLevelForScreenSize(
      300, lodLevels, chunkWidth, fov70Radians, screenHeight, LodDetailLevel.Performance
    );

    // Maximum target (1px) is easier to meet, so can use coarser LOD
    expect(maxDetail).toBeGreaterThanOrEqual(perfDetail);
  });

  it('returns 0 for empty lodLevels array', () => {
    const lod = getLodLevelForScreenSize(
      100, [], chunkWidth, fov70Radians, screenHeight, LodDetailLevel.Balanced
    );
    expect(lod).toBe(0);
  });

  it('returns valid LOD index within array bounds', () => {
    for (const distance of [1, 10, 100, 500, 1000]) {
      for (const detail of [LodDetailLevel.Maximum, LodDetailLevel.High, LodDetailLevel.Balanced, LodDetailLevel.Performance]) {
        const lod = getLodLevelForScreenSize(
          distance, lodLevels, chunkWidth, fov70Radians, screenHeight, detail
        );
        expect(lod).toBeGreaterThanOrEqual(0);
        expect(lod).toBeLessThan(lodLevels.length);
      }
    }
  });

  it('returns finest LOD when very close (traditional LOD behavior)', () => {
    // Traditional LOD: use finest detail when close
    const lod = getLodLevelForScreenSize(
      1, lodLevels, chunkWidth, fov70Radians, screenHeight, LodDetailLevel.Balanced
    );
    // At distance=1, we want maximum detail - LOD 0
    expect(lod).toBe(0); // Finest LOD
  });
});

=== src/terrain/LodUtils.ts ===
/**
 * Pure utility functions for LOD (Level of Detail) calculations
 */

/**
 * Cardinal directions for neighbor chunks
 */
export type CardinalDirection = 'north' | 'south' | 'east' | 'west';

/**
 * Neighbor LOD levels for edge stitching
 */
export interface NeighborLods {
  north: number;
  south: number;
  east: number;
  west: number;
}

/**
 * Get the LOD level index for a given distance from camera.
 * Returns the index into lodLevels array (0 = highest detail).
 * 
 * @param distance - Distance from camera in world units
 * @param lodDistances - Array of distance thresholds, e.g. [0, 100, 200, 400]
 * @returns LOD level index (0 to lodDistances.length - 1)
 */
export function getLodLevelForDistance(
  distance: number,
  lodDistances: readonly number[]
): number {
  if (lodDistances.length === 0) {
    return 0;
  }

  // Find the highest LOD level where distance >= threshold
  for (let i = lodDistances.length - 1; i >= 0; i--) {
    if (distance >= lodDistances[i]) {
      return i;
    }
  }

  return 0;
}

/**
 * Get the resolution for a given LOD level index.
 * 
 * @param lodIndex - Index into lodLevels array
 * @param lodLevels - Array of resolutions, e.g. [512, 256, 128, 64]
 * @returns Resolution value, or highest resolution if index invalid
 */
export function getResolutionForLodLevel(
  lodIndex: number,
  lodLevels: readonly number[]
): number {
  if (lodLevels.length === 0) {
    return 512; // Default fallback
  }

  if (lodIndex < 0) {
    return lodLevels[0];
  }

  if (lodIndex >= lodLevels.length) {
    return lodLevels[lodLevels.length - 1];
  }

  return lodLevels[lodIndex];
}

/**
 * Get grid keys for the four cardinal neighbors of a chunk.
 * 
 * @param gridX - Chunk grid X coordinate
 * @param gridZ - Chunk grid Z coordinate
 * @returns Object with neighbor keys for each direction
 */
export function getNeighborKeys(
  gridX: number,
  gridZ: number
): Record<CardinalDirection, string> {
  return {
    north: `${gridX},${gridZ - 1}`,
    south: `${gridX},${gridZ + 1}`,
    east: `${gridX + 1},${gridZ}`,
    west: `${gridX - 1},${gridZ}`,
  };
}

/**
 * Parse a grid key string into coordinates.
 * 
 * @param gridKey - Grid key in format "x,z"
 * @returns Tuple of [gridX, gridZ]
 */
export function parseGridKey(gridKey: string): [number, number] {
  const [x, z] = gridKey.split(',').map(Number);
  return [x, z];
}

/**
 * Create a grid key from coordinates.
 * 
 * @param gridX - Chunk grid X coordinate
 * @param gridZ - Chunk grid Z coordinate
 * @returns Grid key string
 */
export function createGridKey(gridX: number, gridZ: number): string {
  return `${gridX},${gridZ}`;
}

/**
 * Calculate the world-space center position of a chunk.
 * Chunks are centered around their grid position (gridX * chunkWidth, gridZ * chunkDepth).
 * 
 * @param gridX - Chunk grid X coordinate
 * @param gridZ - Chunk grid Z coordinate
 * @param chunkWidth - Width of each chunk in world units
 * @param chunkDepth - Depth of each chunk in world units
 * @returns Object with x, z world coordinates
 */
export function getChunkWorldCenter(
  gridX: number,
  gridZ: number,
  chunkWidth: number,
  chunkDepth: number
): { x: number; z: number } {
  // Chunks are centered at gridX * chunkWidth, gridZ * chunkDepth
  return {
    x: gridX * chunkWidth,
    z: gridZ * chunkDepth,
  };
}

/**
 * Calculate distance from a point to the nearest point on a chunk rectangle.
 * Projects the camera position onto the chunk's plane (clamps X/Z to chunk bounds),
 * then calculates 3D distance from camera to that projected point.
 * 
 * @param pointX - Camera X coordinate
 * @param pointY - Camera Y coordinate (height)
 * @param pointZ - Camera Z coordinate
 * @param gridX - Chunk grid X coordinate
 * @param gridZ - Chunk grid Z coordinate
 * @param chunkWidth - Width of each chunk
 * @param chunkDepth - Depth of each chunk
 * @returns 3D distance in world units from camera to nearest point on chunk plane
 */
export function getDistanceToChunk(
  pointX: number,
  pointY: number,
  pointZ: number,
  gridX: number,
  gridZ: number,
  chunkWidth: number,
  chunkDepth: number
): number {
  // Calculate chunk bounds in world space
  // Chunks are CENTERED around their grid position, not starting at the corner
  const centerX = gridX * chunkWidth;
  const centerZ = gridZ * chunkDepth;
  const minX = centerX - chunkWidth / 2;
  const maxX = centerX + chunkWidth / 2;
  const minZ = centerZ - chunkDepth / 2;
  const maxZ = centerZ + chunkDepth / 2;
  
  // Project camera position onto chunk plane by clamping X and Z to chunk bounds
  // This finds the nearest point on the chunk rectangle in the XZ plane
  const nearestX = Math.max(minX, Math.min(maxX, pointX));
  const nearestZ = Math.max(minZ, Math.min(maxZ, pointZ));
  
  // The projected point is on the chunk plane at Y=0 (terrain height)
  const nearestY = 0;
  
  // Calculate 3D distance from camera to the projected point on chunk plane
  const dx = pointX - nearestX;
  const dy = pointY - nearestY;
  const dz = pointZ - nearestZ;
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
}

// ============================================================================
// Screen-space LOD selection
// ============================================================================

/**
 * Default terrain tilt angle for screen-space projection (15 degrees in radians)
 */
const DEFAULT_TERRAIN_TILT_RADIANS = Math.PI / 12;

/**
 * Target screen-space triangle size for LOD selection.
 * Lower values = more detail, higher values = better performance.
 */
export enum LodDetailLevel {
  /** Maximum detail - ~1 pixel triangles */
  Maximum = 1,
  /** High detail - ~2 pixel triangles */
  High = 2,
  /** Balanced detail/performance - ~4 pixel triangles */
  Balanced = 4,
  /** Performance focused - ~8 pixel triangles */
  Performance = 8,
}

/**
 * Calculate triangle edge length for a given LOD resolution.
 * For a grid with `resolution` vertices over `chunkWidth`, each triangle
 * edge spans chunkWidth / (resolution - 1).
 * 
 * @param resolution - Number of vertices per edge (e.g., 512, 256, 128, 64)
 * @param chunkWidth - Width of the chunk in world units
 * @returns Triangle edge length in world units
 */
export function getTriangleEdgeLength(
  resolution: number,
  chunkWidth: number
): number {
  if (resolution <= 1) {
    return chunkWidth;
  }
  return chunkWidth / (resolution - 1);
}

/**
 * Calculate screen-space size of a world-space length at a given distance.
 * Uses perspective projection with optional terrain tilt factor.
 * 
 * @param worldSize - Size in world units
 * @param distance - Distance from camera in world units
 * @param fovRadians - Camera field of view in radians
 * @param screenHeight - Screen height in pixels
 * @param tiltAngleRadians - Terrain tilt angle (default 15°)
 * @returns Size in screen pixels
 */
export function projectToScreenSpace(
  worldSize: number,
  distance: number,
  fovRadians: number,
  screenHeight: number,
  tiltAngleRadians: number = DEFAULT_TERRAIN_TILT_RADIANS
): number {
  if (distance <= 0) {
    return screenHeight; // Very close = full screen
  }
  const tanHalfFov = Math.tan(fovRadians / 2);
  return (worldSize * screenHeight * Math.cos(tiltAngleRadians)) /
         (2 * distance * tanHalfFov);
}

/**
 * Get LOD level based on screen-space triangle size.
 * Traditional LOD: finest detail when close, coarser when far.
 * Uses screen-space calculation to determine when triangles are "good enough".
 * 
 * @param distance - Distance from camera in world units
 * @param lodLevels - Array of resolutions (highest to lowest, e.g., [512, 256, 128, 64])
 * @param chunkWidth - Width of chunk in world units
 * @param fovRadians - Camera FOV in radians
 * @param screenHeight - Screen height in pixels
 * @param targetPixels - Target minimum triangle size (from LodDetailLevel)
 * @returns LOD level index (0 = highest detail)
 */
export function getLodLevelForScreenSize(
  distance: number,
  lodLevels: readonly number[],
  chunkWidth: number,
  fovRadians: number,
  screenHeight: number,
  targetPixels: LodDetailLevel
): number {
  if (lodLevels.length === 0) {
    return 0;
  }

  // Traditional LOD: use finest detail when close, coarser when far
  // Iterate from finest (0) to coarsest, return finest where triangles >= target
  for (let i = 0; i < lodLevels.length; i++) {
    const edgeLength = getTriangleEdgeLength(lodLevels[i], chunkWidth);
    const screenSize = projectToScreenSpace(edgeLength, distance, fovRadians, screenHeight);
    if (screenSize >= targetPixels) {
      return i;
    }
  }

  // At far distances, no LOD meets target - use coarsest (saves triangles)
  return lodLevels.length - 1;
}

=== src/terrain/TerrainManager.ts ===
import { BufferAttribute, BufferGeometry, LOD, Mesh, Scene, Vector3, Camera, MeshBasicMaterial, Color, PerspectiveCamera, Raycaster } from 'three';
import { MoonMaterial } from '../shaders/MoonMaterial';
import type { TerrainArgs } from './terrain';
import type { TerrainWorkerResult } from './TerrainWorker';
import { 
  getNeighborKeys, 
  parseGridKey,
  getDistanceToChunk,
  getLodLevelForScreenSize,
  LodDetailLevel,
  type NeighborLods 
} from './LodUtils';
import { computeStitchedIndices } from './EdgeStitcher';
import { ChunkRequestQueue } from './ChunkRequestQueue';

export interface TerrainConfig {
  renderDistance: number;
  chunkWidth: number;
  chunkDepth: number;
  /** Resolution levels from highest to lowest, e.g. [512, 256, 128, 64] */
  lodLevels: number[];
  /** Target screen-space triangle size for LOD selection */
  lodDetailLevel: LodDetailLevel;
  /** Debug mode: render wireframe triangles with different color per chunk */
  debugWireframe?: boolean;
  /** Number of terrain generation workers (default: 3) */
  workerCount?: number;
}

/**
 * Number of chunks that the high-priority worker targets (3x3 grid)
 */
const HP_WORKER_TARGET_CHUNKS = 9;

/**
 * Number of nearest chunks that get Tier 1 priority boost (~5x5 grid)
 */
const NEAREST_CHUNKS_HIGH_PRIORITY = 25;

/**
 * State for a single terrain worker
 */
interface WorkerState {
  worker: Worker;
  busy: boolean;
  isHighPriority: boolean;
}

/**
 * Entry for a chunk with LOD support
 */
interface ChunkLodEntry {
  /** THREE.LOD object containing all mesh levels */
  lod: LOD;
  /** Meshes at each LOD level (index matches lodLevels) */
  meshes: (Mesh | null)[];
  /** Track which LOD levels have been built */
  builtLevels: Set<number>;
  /** Current active LOD level (for edge stitching) */
  currentLodLevel: number;
  /** Original index buffers before stitching (for restoration) */
  originalIndices: (Uint32Array | null)[];
}

export class TerrainManager {
  private terrainGrid: Map<string, ChunkLodEntry> = new Map();
  private requestQueue: ChunkRequestQueue;
  private workers: WorkerState[] = [];
  private inFlight: Set<string> = new Set(); // "gridKey:lodLevel"
  private hpWorkerKeys: Set<string> = new Set(); // Nearest 9 chunks for HP worker
  private material: MoonMaterial;
  private scene: Scene;
  private config: TerrainConfig;
  private baseTerrainArgs: Omit<TerrainArgs, 'resolution' | 'posX' | 'posZ'>;
  private camera: Camera | null = null;
  private cameraForward: Vector3 = new Vector3();
  private debugMode: boolean = false;
  private collisionLodLevel: number = 0;
  private raycaster: Raycaster = new Raycaster();

  constructor(scene: Scene, config: TerrainConfig) {
    this.scene = scene;
    this.config = config;
    this.debugMode = config.debugWireframe ?? false;
    // Single shared material instance for all chunks (critical for performance)
    this.material = new MoonMaterial();

    // Base terrain args (without position/resolution - those are per-request)
    this.baseTerrainArgs = {
      seed: 0,
      gain: 0.5,
      lacunarity: 2,
      frequency: 0.07,
      amplitude: 0.5,
      altitude: 0.1,
      falloff: 0.0,
      erosion: 0.6,
      erosionSoftness: 0.3,
      rivers: 0.18,
      riverWidth: 0.35,
      riverFalloff: 0.06,
      lakes: 0.5,
      lakesFalloff: 0.5,
      riversFrequency: 0.13,
      smoothLowerPlanes: 0,
      octaves: 10,
      width: config.chunkWidth,
      depth: config.chunkDepth,
      renderDistance: config.renderDistance,
    };

    this.requestQueue = new ChunkRequestQueue({
      chunkWidth: config.chunkWidth,
      chunkDepth: config.chunkDepth,
    });

    this.setupWorkers();

    // Identify the LOD level closest to resolution 32 for collision detection
    this.collisionLodLevel = this.findCollisionLodLevel(32);
  }

  /**
   * Find the LOD level index closest to target resolution
   */
  private findCollisionLodLevel(targetResolution: number): number {
    let closestIndex = 0;
    let minDiff = Infinity;

    for (let i = 0; i < this.config.lodLevels.length; i++) {
      const diff = Math.abs(this.config.lodLevels[i] - targetResolution);
      if (diff <= minDiff) {
        minDiff = diff;
        closestIndex = i;
      }
    }
    return closestIndex;
  }

  /**
   * Set camera reference for LOD updates
   */
  setCamera(camera: Camera): void {
    this.camera = camera;
  }

  /**
   * Compute the distance threshold for a given LOD level.
   * 
   * Traditional LOD: finest detail when close, coarser when far.
   * - LOD 0 (finest) at distance 0
   * - Coarser LODs at increasing distances
   */
  private computeLodDistance(lodLevel: number): number {
    // Finest LOD shows at distance 0
    if (lodLevel === 0) {
      return 0;
    }

    // For coarser LODs: compute distance where the PREVIOUS FINER LOD's
    // triangles fall below target pixels (time to switch to coarser)
    const finerLodIndex = lodLevel - 1;
    const finerResolution = this.config.lodLevels[finerLodIndex];
    const edgeLength = this.config.chunkWidth / (finerResolution - 1);
    
    // Get camera parameters
    const fov = (this.camera as PerspectiveCamera)?.fov ?? 70;
    const fovRadians = (fov * Math.PI) / 180;
    const screenHeight = window.innerHeight;
    const tanHalfFov = Math.tan(fovRadians / 2);
    const tiltFactor = Math.cos(Math.PI / 12); // 15 degrees

    // Solve for distance where finer LOD's triangles = targetPixels
    // At this distance, we can switch to the coarser LOD
    const targetPixels = this.config.lodDetailLevel;
    const distance = (edgeLength * screenHeight * tiltFactor) / (2 * targetPixels * tanHalfFov);

    return distance;
  }

  private setupWorkers(): void {
    const count = Math.max(1, this.config.workerCount ?? 3);
    
    for (let i = 0; i < count; i++) {
      const worker = new Worker(
        new URL('./TerrainWorker.ts', import.meta.url),
        { type: 'module' }
      );

      worker.onmessage = (e: MessageEvent<TerrainWorkerResult>) => {
        this.handleWorkerResult(e.data, i);
      };

      this.workers.push({
        worker,
        busy: false,
        isHighPriority: i === 0, // First worker is high-priority
      });
    }
  }

  /**
   * Handle mesh data from worker
   */
  private handleWorkerResult(result: TerrainWorkerResult, workerIndex: number): void {
    const { positions, normals, index, biome, gridKey, lodLevel } = result;
    
    // Worker is no longer busy
    this.workers[workerIndex].busy = false;
    
    // Clear from in-flight
    const requestKey = `${gridKey}:${lodLevel}`;
    this.inFlight.delete(requestKey);

    // Get or create chunk entry
    let entry = this.terrainGrid.get(gridKey);
    if (!entry) {
      entry = this.createChunkEntry(gridKey);
      this.terrainGrid.set(gridKey, entry);
    }

    // Create geometry
    const geometry = new BufferGeometry();
    geometry.setAttribute(
      'position',
      new BufferAttribute(new Float32Array(positions), 3)
    );
    geometry.setAttribute(
      'normal',
      new BufferAttribute(new Float32Array(normals), 3)
    );
    if (biome) {
      geometry.setAttribute(
        'biome',
        new BufferAttribute(new Float32Array(biome), 3)
      );
    }
    if (index) {
      geometry.setIndex(new BufferAttribute(new Uint32Array(index), 1));
      // Store original indices for stitching restoration
      entry.originalIndices[lodLevel] = new Uint32Array(index);
    }

    // Compute bounding sphere for correct frustum culling
    geometry.computeBoundingSphere();

    // Expand bounding sphere to account for vertex shader curvature transformation
    if (!this.debugMode && this.material.getParam('enableCurvature')) {
      const planetRadius = this.material.getParam('planetRadius');
      
      // Calculate maximum distance from chunk center to corner in XZ plane
      const halfWidth = this.config.chunkWidth / 2;
      const halfDepth = this.config.chunkDepth / 2;
      const maxDist = Math.sqrt(halfWidth * halfWidth + halfDepth * halfDepth);
      
      // Maximum curvature drop occurs at the furthest corner from camera
      // Formula: curvatureDrop = distSq / (2 * planetRadius)
      const maxCurvatureDrop = (maxDist * maxDist) / (2 * planetRadius);
      
      // Expand bounding sphere to encompass transformed geometry
      // Move center down by half the drop, increase radius by half the drop
      if (geometry.boundingSphere) {
        geometry.boundingSphere.center.y -= maxCurvatureDrop / 2;
        geometry.boundingSphere.radius += maxCurvatureDrop / 2;
      }
    }

    // Create mesh with appropriate material
    const material = this.debugMode 
      ? this.createDebugMaterial(gridKey)
      : this.material;
    const mesh = new Mesh(geometry, material);
    
    // Store mesh at this LOD level
    if (entry.meshes[lodLevel]) {
      // Dispose old mesh at this level
      entry.meshes[lodLevel]!.geometry.dispose();
      entry.lod.remove(entry.meshes[lodLevel]!);
    }
    
    entry.meshes[lodLevel] = mesh;
    entry.builtLevels.add(lodLevel);

    // Add to LOD object with computed distance threshold
    const distance = this.computeLodDistance(lodLevel);
    entry.lod.addLevel(mesh, distance);

    if (!this.debugMode) {
      this.material.needsUpdate = true;
    }

    // Dispatch next request from queue
    this.dispatchNext();
  }

  /**
   * Generate a color from a grid key (for debug visualization)
   */
  private generateChunkColor(gridKey: string): Color {
    // Simple hash function to generate consistent color from grid key
    let hash = 0;
    for (let i = 0; i < gridKey.length; i++) {
      hash = gridKey.charCodeAt(i) + ((hash << 5) - hash);
    }
    
    // Convert to RGB values (avoid too dark colors for visibility)
    const r = ((hash & 0xFF0000) >> 16) % 200 + 55;
    const g = ((hash & 0x00FF00) >> 8) % 200 + 55;
    const b = (hash & 0x0000FF) % 200 + 55;
    
    return new Color(r / 255, g / 255, b / 255);
  }

  /**
   * Create a debug material for a specific chunk
   */
  private createDebugMaterial(gridKey: string): MeshBasicMaterial {
    const color = this.generateChunkColor(gridKey);
    return new MeshBasicMaterial({ 
      wireframe: true, 
      color: color 
    });
  }

  /**
   * Toggle debug wireframe mode
   */
  toggleDebugMode(): void {
    this.debugMode = !this.debugMode;
    
    // Update all existing meshes
    for (const [gridKey, entry] of this.terrainGrid.entries()) {
      for (let lodLevel = 0; lodLevel < entry.meshes.length; lodLevel++) {
        const mesh = entry.meshes[lodLevel];
        if (mesh) {
          const oldMaterial = mesh.material;
          
          // Only dispose debug materials (MeshBasicMaterial), never the shared MoonMaterial
          if (oldMaterial instanceof MeshBasicMaterial) {
            oldMaterial.dispose();
          }
          
          // Create new material
          mesh.material = this.debugMode 
            ? this.createDebugMaterial(gridKey)
            : this.material;
        }
      }
    }
    
    console.log(`Debug wireframe mode: ${this.debugMode ? 'ON' : 'OFF'}`);
  }

  /**
   * Create a new chunk entry with LOD object
   */
  private createChunkEntry(gridKey: string): ChunkLodEntry {
    const [gridX, gridZ] = parseGridKey(gridKey);
    
    const lod = new LOD();
    lod.position.x = gridX * this.config.chunkWidth;
    lod.position.z = gridZ * this.config.chunkDepth;
    
    // Disable Three.js LOD auto-update - we manually control mesh visibility
    lod.autoUpdate = false;
    
    // Add LOD to scene
    this.scene.add(lod);

    return {
      lod,
      meshes: new Array(this.config.lodLevels.length).fill(null),
      builtLevels: new Set(),
      currentLodLevel: 0,
      originalIndices: new Array(this.config.lodLevels.length).fill(null),
    };
  }

  /**
   * Request a specific LOD level for a chunk (adds to priority queue)
   */
  private requestChunkLod(gridKey: string, lodLevel: number): void {
    // Already in queue?
    if (this.requestQueue.has(gridKey, lodLevel)) {
      return;
    }

    // Already built?
    const entry = this.terrainGrid.get(gridKey);
    if (entry?.builtLevels.has(lodLevel)) {
      return;
    }

    const [gridX, gridZ] = parseGridKey(gridKey);
    const resolution = this.config.lodLevels[lodLevel] ?? this.config.lodLevels[0];

    const args: TerrainArgs = {
      ...this.baseTerrainArgs,
      resolution,
      posX: gridX * this.config.chunkWidth / 25,
      posZ: gridZ * this.config.chunkDepth / 25,
    };

    // Add to priority queue (will be sorted and dispatched in update())
    this.requestQueue.add({ gridKey, lodLevel, terrainArgs: args });
  }

  /**
   * Dispatch next highest-priority requests to idle workers
   */
  private dispatchNext(): void {
    for (const workerState of this.workers) {
      if (workerState.busy) {
        continue;
      }

      // High-priority worker: try matching nearest 9 chunks first, then any
      // Normal workers: take next available from queue
      const request = workerState.isHighPriority
        ? this.requestQueue.shiftMatching(this.hpWorkerKeys, this.inFlight) || this.requestQueue.shiftAny(this.inFlight)
        : this.requestQueue.shiftAny(this.inFlight);

      if (request) {
        const key = `${request.gridKey}:${request.lodLevel}`;
        this.inFlight.add(key);
        workerState.busy = true;
        workerState.worker.postMessage({
          terrainArgs: request.terrainArgs,
          gridKey: request.gridKey,
          lodLevel: request.lodLevel,
        });
      }
    }
  }

  private getNearbyChunkPositionKeys(center: Vector3, radius: number): string[] {
    const keys: { key: string; distance: number }[] = [];
    const cx = Math.round(center.x);
    const cz = Math.round(center.z);
    const r = Math.ceil(radius);

    for (let x = cx - r; x <= cx + r; x++) {
      for (let z = cz - r; z <= cz + r; z++) {
        const dx = x - center.x;
        const dz = z - center.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        if (distance <= radius) {
          keys.push({ key: `${x},${z}`, distance });
        }
      }
    }
    keys.sort((a, b) => a.distance - b.distance);
    return keys.map((k) => k.key);
  }

  /**
   * Determine which LOD level a chunk should use based on screen-space triangle size.
   * Optimized version that accepts pre-calculated camera parameters.
   */
  private getLodLevelForChunkOptimized(
    gridKey: string,
    cameraWorldPos: Vector3,
    fovRadians: number,
    screenHeight: number
  ): number {
    const [gridX, gridZ] = parseGridKey(gridKey);
    const distance = getDistanceToChunk(
      cameraWorldPos.x,
      cameraWorldPos.y,
      cameraWorldPos.z,
      gridX,
      gridZ,
      this.config.chunkWidth,
      this.config.chunkDepth
    );

    const desiredLod = getLodLevelForScreenSize(
      distance,
      this.config.lodLevels,
      this.config.chunkWidth,
      fovRadians,
      screenHeight,
      this.config.lodDetailLevel
    );

    return desiredLod;
  }

  /**
   * Update terrain based on camera position
   */
  update(cameraPosition: Vector3): void {
    // Get camera forward direction for priority calculation
    if (this.camera) {
      this.camera.getWorldDirection(this.cameraForward);
    }

    // Convert camera position to grid coordinates for chunk selection
    const camPosInGrid = cameraPosition.clone();
    camPosInGrid.x /= this.config.chunkWidth;
    camPosInGrid.z /= this.config.chunkDepth;
    camPosInGrid.y = 0;

    const renderDistance = Math.floor(this.config.renderDistance);

    // Get chunks that should be loaded
    const nearbyKeys = this.getNearbyChunkPositionKeys(camPosInGrid, renderDistance);
    const nearbySet = new Set(nearbyKeys);

    // Prune stale requests (chunks no longer in render distance)
    this.requestQueue.pruneStale(nearbySet);

    // Pre-calculate camera parameters once (don't recalculate thousands of times!)
    const fov = (this.camera as PerspectiveCamera)?.fov ?? 70;
    const fovRadians = (fov * Math.PI) / 180;
    const screenHeight = window.innerHeight;

    // Request chunks and their appropriate LOD levels
    for (const gridKey of nearbyKeys) {
      const desiredLod = this.getLodLevelForChunkOptimized(
        gridKey,
        cameraPosition,
        fovRadians,
        screenHeight
      );

      // Ensure chunk entry exists
      if (!this.terrainGrid.has(gridKey)) {
        const entry = this.createChunkEntry(gridKey);
        this.terrainGrid.set(gridKey, entry);
      }

      // Request the desired LOD level if not built
      const entry = this.terrainGrid.get(gridKey)!;
      
      // ALWAYS ensure the collision LOD level is built for physics
      if (!entry.builtLevels.has(this.collisionLodLevel)) {
        this.requestChunkLod(gridKey, this.collisionLodLevel);
      }

      if (!entry.builtLevels.has(desiredLod)) {
        this.requestChunkLod(gridKey, desiredLod);
      }

      // ALWAYS ensure the coarsest LOD level is requested for all chunks (horizon fill)
      const coarsestLod = this.config.lodLevels.length - 1;
      if (!entry.builtLevels.has(coarsestLod)) {
        this.requestChunkLod(gridKey, coarsestLod);
      }

      // Also request adjacent LOD levels for smooth transitions
      // Request one level higher detail (lower index) and one lower detail (higher index)
      if (desiredLod > 0 && !entry.builtLevels.has(desiredLod - 1)) {
        this.requestChunkLod(gridKey, desiredLod - 1);
      }
      if (desiredLod < this.config.lodLevels.length - 1 && !entry.builtLevels.has(desiredLod + 1)) {
        this.requestChunkLod(gridKey, desiredLod + 1);
      }
    }

    // Get nearest chunks for high-priority worker (3x3 grid = 9 chunks)
    this.hpWorkerKeys = new Set(
      nearbyKeys.slice(0, HP_WORKER_TARGET_CHUNKS)
    );

    // Get nearest chunks for Tier 1 priority boost (~5x5 grid = 25 chunks)
    const nearestHighPriorityKeys = new Set(
      nearbyKeys.slice(0, NEAREST_CHUNKS_HIGH_PRIORITY)
    );

    // Sort queue by priority (nearest chunks first, then distance + direction)
    const maxLodLevel = this.config.lodLevels.length - 1;
    this.requestQueue.sort(cameraPosition, this.cameraForward, nearestHighPriorityKeys, maxLodLevel);

    // Dispatch next request if worker is idle
    this.dispatchNext();

    // Manually control mesh visibility (bypasses Three.js LOD auto-switching)
    // Also returns actual LOD levels for reuse in edge stitching
    const chunkLodLevels = this.updateChunkVisibility(cameraPosition, fovRadians, screenHeight);

    // Track current LOD levels and update edge stitching (reuses LOD levels from visibility update)
    this.updateEdgeStitching(chunkLodLevels);

    // Remove distant chunks
    for (const gridKey of this.terrainGrid.keys()) {
      if (!nearbySet.has(gridKey)) {
        this.removeChunk(gridKey);
      }
    }
  }

  /**
   * Update mesh visibility for all chunks.
   * Manually controls which LOD mesh is visible, bypassing Three.js LOD auto-switching.
   * Shows the best available LOD (desired or next coarser if not built).
   * Returns a map of chunk keys to their actual LOD levels for reuse.
   */
  private updateChunkVisibility(
    cameraPosition: Vector3,
    fovRadians: number,
    screenHeight: number
  ): Map<string, number> {
    const chunkLodLevels = new Map<string, number>();
    
    for (const [gridKey, entry] of this.terrainGrid.entries()) {
      const desiredLod = this.getLodLevelForChunkOptimized(
        gridKey,
        cameraPosition,
        fovRadians,
        screenHeight
      );
      
      // Find best available LOD (desired or next coarser)
      let actualLod = desiredLod;
      if (!entry.builtLevels.has(actualLod)) {
        // Try coarser
        while (actualLod < this.config.lodLevels.length && !entry.builtLevels.has(actualLod)) {
          actualLod++;
        }
        
        // If no coarser LOD available, try finer
        if (actualLod >= this.config.lodLevels.length) {
          actualLod = desiredLod - 1;
          while (actualLod >= 0 && !entry.builtLevels.has(actualLod)) {
            actualLod--;
          }
        }
      }
      
      if (actualLod < 0 || actualLod >= this.config.lodLevels.length) {
        actualLod = entry.builtLevels.values().next().value ?? 0;
      }
      
      // Store actual LOD level for reuse
      entry.currentLodLevel = actualLod;
      chunkLodLevels.set(gridKey, actualLod);
      
      // Set visibility: only the actual LOD mesh is visible
      for (let i = 0; i < entry.meshes.length; i++) {
        const mesh = entry.meshes[i];
        if (mesh) {
          mesh.visible = (i === actualLod);
        }
      }
    }
    
    return chunkLodLevels;
  }

  /**
   * Update edge stitching for chunks that have LOD mismatches with neighbors.
   * Reuses LOD levels from updateChunkVisibility to avoid recalculating.
   */
  private updateEdgeStitching(chunkLodLevels: Map<string, number>): void {
    // Update edge stitching where needed
    for (const [gridKey, entry] of this.terrainGrid.entries()) {
      const myLod = entry.currentLodLevel;
      const [gridX, gridZ] = parseGridKey(gridKey);
      const neighbors = getNeighborKeys(gridX, gridZ);

      // Get neighbor LOD levels (default to same level if neighbor doesn't exist)
      const neighborLods: NeighborLods = {
        north: chunkLodLevels.get(neighbors.north) ?? myLod,
        south: chunkLodLevels.get(neighbors.south) ?? myLod,
        east: chunkLodLevels.get(neighbors.east) ?? myLod,
        west: chunkLodLevels.get(neighbors.west) ?? myLod,
      };

      // Update stitching for the current LOD mesh
      this.applyEdgeStitching(entry, myLod, neighborLods);
    }
  }

  /**
   * Apply edge stitching to a specific LOD level of a chunk
   */
  private applyEdgeStitching(
    entry: ChunkLodEntry,
    lodLevel: number,
    neighborLods: NeighborLods
  ): void {
    const mesh = entry.meshes[lodLevel];
    if (!mesh) return;

    const resolution = this.config.lodLevels[lodLevel];
    if (!resolution) return;

    // Check if stitching is needed (any neighbor has lower resolution = higher LOD index)
    const needsStitching = 
      neighborLods.north > lodLevel ||
      neighborLods.south > lodLevel ||
      neighborLods.east > lodLevel ||
      neighborLods.west > lodLevel;

    if (!needsStitching) {
      // Restore original indices if we have them
      const original = entry.originalIndices[lodLevel];
      if (original && mesh.geometry.index) {
        mesh.geometry.setIndex(new BufferAttribute(original.slice(), 1));
      }
      return;
    }

    // Compute stitched indices
    const stitchedIndices = computeStitchedIndices(
      resolution,
      neighborLods,
      lodLevel,
      this.config.lodLevels
    );

    // Apply to geometry
    mesh.geometry.setIndex(new BufferAttribute(stitchedIndices, 1));
  }

  /**
   * Remove a chunk and clean up its resources
   */
  private removeChunk(gridKey: string): void {
    const entry = this.terrainGrid.get(gridKey);
    if (!entry) return;

    // Remove LOD from scene
    this.scene.remove(entry.lod);

    // Dispose all mesh geometries
    for (const mesh of entry.meshes) {
      if (mesh) {
        mesh.geometry.dispose();
      }
    }

    // Note: Queue pruning handles removing stale requests

    this.terrainGrid.delete(gridKey);
  }

  /**
   * Get number of active chunks
   */
  getActiveChunkCount(): number {
    return this.terrainGrid.size;
  }

  /**
   * Get total number of workers
   */
  getWorkerCount(): number {
    return this.workers.length;
  }

  /**
   * Get number of workers currently processing chunks
   */
  getActiveWorkerCount(): number {
    return this.workers.filter(w => w.busy).length;
  }

  /**
   * Get build queue length
   */
  getBuildQueueLength(): number {
    return this.requestQueue.length + this.getActiveWorkerCount();
  }

  /**
   * Get the material instance (for UI control)
   */
  getMaterial(): MoonMaterial {
    return this.material;
  }

  /**
   * Get the height of the terrain at a given world (x, z) coordinate.
   * Uses raycasting against the collision LOD mesh for efficiency.
   */
  getHeightAt(x: number, z: number): number | null {
    // Find which chunk this (x, z) belongs to
    const gridX = Math.round(x / this.config.chunkWidth);
    const gridZ = Math.round(z / this.config.chunkDepth);
    const gridKey = `${gridX},${gridZ}`;

    const entry = this.terrainGrid.get(gridKey);
    if (!entry) return null;

    // Use collision LOD mesh if available
    const mesh = entry.meshes[this.collisionLodLevel];
    if (!mesh || !entry.builtLevels.has(this.collisionLodLevel)) {
      // Fallback: use any available LOD mesh
      let fallbackMesh: Mesh | null = null;
      for (let i = this.config.lodLevels.length - 1; i >= 0; i--) {
        if (entry.meshes[i] && entry.builtLevels.has(i)) {
          fallbackMesh = entry.meshes[i];
          break;
        }
      }
      if (!fallbackMesh) return null;
      
      return this.raycastHeight(x, z, fallbackMesh);
    }

    return this.raycastHeight(x, z, mesh);
  }

  private raycastHeight(x: number, z: number, mesh: Mesh): number | null {
    // Ensure world matrix is up to date for accurate raycasting
    mesh.updateMatrixWorld(true);

    // Start ray far above terrain
    const rayOrigin = new Vector3(x, 10000, z);
    const rayDirection = new Vector3(0, -1, 0);
    this.raycaster.set(rayOrigin, rayDirection);

    const intersects = this.raycaster.intersectObject(mesh, false);
    if (intersects.length > 0) {
      return intersects[0].point.y;
    }

    return null;
  }

  /**
   * Debug: Log distance and LOD information for all chunks
   * Helps identify distance calculation problems causing inconsistent LODs
   */
  logChunkDistancesAndLods(cameraPosition: Vector3): void {
    if (!this.camera) {
      console.warn('Cannot log chunk distances: camera not set');
      return;
    }

    // Pre-calculate camera parameters (same as in updateChunkVisibility)
    const fov = (this.camera as PerspectiveCamera)?.fov ?? 70;
    const fovRadians = (fov * Math.PI) / 180;
    const screenHeight = window.innerHeight;

    // Collect chunk data
    const chunkData: Array<{
      gridKey: string;
      distance: number;
      desiredLod: number;
      currentLod: number;
    }> = [];

    for (const [gridKey, entry] of this.terrainGrid.entries()) {
      const [gridX, gridZ] = parseGridKey(gridKey);
      
      // Calculate distance to nearest point on chunk
      const distance = getDistanceToChunk(
        cameraPosition.x,
        cameraPosition.y,
        cameraPosition.z,
        gridX,
        gridZ,
        this.config.chunkWidth,
        this.config.chunkDepth
      );

      // Calculate desired LOD level
      const desiredLod = this.getLodLevelForChunkOptimized(
        gridKey,
        cameraPosition,
        fovRadians,
        screenHeight
      );

      // Get current LOD level
      const currentLod = entry.currentLodLevel;

      chunkData.push({
        gridKey,
        distance,
        desiredLod,
        currentLod,
      });
    }

    // Sort by distance (closest first)
    chunkData.sort((a, b) => a.distance - b.distance);

    // Log formatted output
    console.log('=== Chunk Distance & LOD Debug ===');
    console.log('Grid Key | Distance (m) | Desired LOD | Current LOD | Match');
    console.log('---------|--------------|-------------|-------------|------');
    
    for (const data of chunkData) {
      const match = data.desiredLod === data.currentLod ? '✓' : '✗';
      const matchColor = data.desiredLod === data.currentLod ? '' : 'color: orange';
      console.log(
        `%c${data.gridKey.padEnd(9)} | ${data.distance.toFixed(2).padStart(12)} | ${String(data.desiredLod).padStart(11)} | ${String(data.currentLod).padStart(11)} | ${match}`,
        matchColor
      );
    }

    // Summary statistics
    const mismatches = chunkData.filter(d => d.desiredLod !== d.currentLod);
    console.log(`\nTotal chunks: ${chunkData.length}`);
    console.log(`Mismatches: ${mismatches.length}`);
    if (mismatches.length > 0) {
      console.log('\nChunks with LOD mismatches:');
      for (const mismatch of mismatches) {
        console.log(
          `  ${mismatch.gridKey}: distance=${mismatch.distance.toFixed(2)}m, desired=${mismatch.desiredLod}, current=${mismatch.currentLod}`
        );
      }
    }
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    for (const workerState of this.workers) {
      workerState.worker.terminate();
    }
    this.workers = [];
    
    for (const gridKey of this.terrainGrid.keys()) {
      this.removeChunk(gridKey);
    }
    
    this.terrainGrid.clear();
    this.requestQueue.clear();
    this.inFlight.clear();
    this.material.dispose();
  }
}

=== src/terrain/TerrainWorker.ts ===
import { generateTerrain } from './terrain';

export interface TerrainWorkerMessage {
  terrainArgs: Parameters<typeof generateTerrain>[0];
  gridKey: string;
  lodLevel: number;
}

export interface TerrainWorkerResult {
  positions: ArrayLike<number>;
  normals: ArrayLike<number>;
  uvs?: ArrayLike<number>;
  biome?: ArrayLike<number>;
  index?: ArrayLike<number>;
  gridKey: string;
  lodLevel: number;
  resolution: number;
}

self.onmessage = (m: MessageEvent<TerrainWorkerMessage>) => {
    const { terrainArgs, gridKey, lodLevel } = m.data;
    const geometry = generateTerrain(terrainArgs);

    // Extract attributes into transferable objects
    const index = geometry.index?.array; // keep full TypedArray, not just buffer

    const result: TerrainWorkerResult = {
        positions: geometry.attributes.position.array,
        normals: geometry.attributes.normal.array,
        uvs: geometry.attributes.uv?.array,
        biome: geometry.attributes.biome?.array,
        index,
        gridKey,
        lodLevel,
        resolution: terrainArgs.resolution,
    };

    postMessage(result);
};

=== src/terrain/displacements.ts ===
import * as THREE from 'three';
import { BufferGeometry } from 'three';

export function displaceY(
  geometry: BufferGeometry,
  yFunction: (x: number, z: number) => {y: number, biome: number[]},
  strength: number,
) {
  const position = geometry.attributes.position as THREE.BufferAttribute;

  const biome = new Float32Array(position.count * 3);

  for (let i = 0; i < position.count; i++) {
    const x = position.getX(i);
    const z = position.getZ(i);
    const result = yFunction(x, z);

    biome[i * 3 + 0] = result.biome[0];
    biome[i * 3 + 1] = result.biome[1];
    biome[i * 3 + 2] = result.biome[2];

    let newY = result.y * strength;
    position.setY(i, newY );
  }

  geometry.setAttribute("biome", new THREE.Float32BufferAttribute(biome, 3));
  position.needsUpdate = true;
  geometry.computeVertexNormals();
}

=== src/terrain/math-operators.ts ===
import { MathUtils } from "three";


export function mapRangeClamped(val: number, a1: number, a2: number, b1: number, b2: number) {
  return MathUtils.clamp(MathUtils.mapLinear(val, a1, a2, b1, b2), b1, b2);
}

export function mapRangeSmooth(val: number, a1: number, a2: number, b1: number, b2: number) {
  return MathUtils.mapLinear(MathUtils.smoothstep(val, a1, a2), 0, 1, b1, b2);

}

export function closeTo(a: number, b: number, epsilon: number = 0.01) {
    return Math.abs(a - b) < epsilon;
}

=== src/terrain/noise.ts ===
import alea from 'alea';
import { createNoise2D, NoiseFunction2D } from 'simplex-noise';
import { MathUtils } from 'three';

export type FbmArgs = {
  octaves: number,
  lacunarity: number,
  frequency: number,
  amplitude: number,
  gain: number,
  smoothLowerPlanes: number,
  seed: number,
}

export class FbmNoiseBuilder {
  private args = {
    octaves: 8,
    seed: 5,
    gain: 0.5,
    frequency: 0.1,
    amplitude: 0.8,
    lacunarity: 1.7,
    smoothLowerPlanes: 0.75,
  }

  octaves(value: number) {
    this.args.octaves = value;
    return this;
  }

  seed(value: number) {
    this.args.seed = value;
    return this;
  }

  gain(value: number) {
    this.args.gain = value;
    return this;
  }

  frequency(value: number) {
    this.args.frequency = value;
    return this;
  }

  amplitude(value: number) {
    this.args.amplitude = value;
    return this;
  }

  lacunarity(value: number) {
    this.args.lacunarity = value;
    return this;
  }

  offset(value: number) {
    this.args.smoothLowerPlanes = value;
    return this;
  }

  build() {
    return createFbmNoise(this.args);
  }
}

export function createFbmNoise(args: FbmArgs) {
  const noises: NoiseFunction2D[] = [];
  for (let i = 0; i < args.octaves; i++) {
    const prng = alea(i + args.seed);
    noises.push(createNoise2D(prng))
  }

  return (x: number, y: number) => {
    let value = 0;
    let amp = args.amplitude;
    let freq = args.frequency;
    for (let i = 0; i < args.octaves; i++) {
      value += amp * noises[i](freq * x, freq * y);
      x *= args.lacunarity;
      y *= args.lacunarity;
      amp *= args.gain;
    }
    return value + args.smoothLowerPlanes;
  }

}

export function normalizeFbmRange(fbmNoise: number) {
  return MathUtils.mapLinear(fbmNoise, -0.4, 0.9, 0, 1);
}


export function debugMinMax(value: number, checkBelow: number, checkAbove: number) {
  if(value < checkBelow) return -.4;
  if(value > checkAbove) return .4;
  return 0;
}

=== src/terrain/terrain.ts ===
import { FbmNoiseBuilder, normalizeFbmRange } from "./noise";
import { displaceY } from "./displacements";
import { closeTo, mapRangeSmooth } from "./math-operators";
import { MathUtils, PlaneGeometry } from "three";
import { mapLinear } from "three/src/math/MathUtils.js";

export type TerrainArgs = {
  seed: number;
  gain: number;
  lacunarity: number;
  frequency: number;
  amplitude: number;
  altitude: number;
  falloff: number;
  erosion: number;
  erosionSoftness: number;
  rivers: number;
  riversFrequency: number;
  riverWidth: number;
  lakes: number;
  lakesFalloff: number;
  riverFalloff: number;
  smoothLowerPlanes: number;
  octaves: number;
  width: number;
  depth: number;
  resolution: number;
  posX: number;
  posZ: number;
  renderDistance: number;
};

export function generateTerrain(args: TerrainArgs) {
  let fbm = new FbmNoiseBuilder()
    .octaves(args.octaves)
    .lacunarity(args.lacunarity)
    .gain(args.gain)
    .seed(args.seed)
    .offset(0.25)
    .amplitude(args.amplitude)
    .frequency(args.frequency)
    .build();

  let fbmValiation = new FbmNoiseBuilder()
    .octaves(1)
    .seed(args.seed + 4)
    .frequency(0.012)
    .build();

  let fbmBiomes = new FbmNoiseBuilder()
    .octaves(2)
    .seed(args.seed + 4)
    .frequency(0.004)
    .build();

  let fbmErosion = new FbmNoiseBuilder()
    .octaves(3)
    .lacunarity(1.8)
    .seed(args.seed + 1)
    .offset(0.3)
    .amplitude(0.2)
    .frequency(args.frequency)
    .build();

  const geometry = new PlaneGeometry(
    args.width,
    args.depth,
    args.resolution,
    args.resolution
  );
  geometry.rotateX(-Math.PI / 2);

  const defaultTerrain = (x: number, z: number) => {
    let terrainNoise = fbm(x + args.posX * 25, z + args.posZ * 25);

    const erosionNoise =
      fbmValiation(x + 500 + args.posX * 25, z + 500 + args.posZ * 25) * 0.6 - 0.1;
    const erosionSoftness = erosionNoise + args.erosionSoftness;
    let erosion = fbmErosion(x + args.posX * 25, z + args.posZ * 25);

    erosion = MathUtils.smoothstep(erosion, 0, 1);
    erosion = Math.pow(erosion, 1 + erosionSoftness);
    erosion = MathUtils.clamp(MathUtils.pingpong(erosion * 2, 1) - 0.3, 0, 100);

    terrainNoise *= MathUtils.lerp(1, erosion, args.erosion);

    const altitudeNoise =
    fbmValiation(x + args.posX * 25, z + args.posZ * 25) * 1.4 - 0.75;
    const altitude = args.altitude + altitudeNoise;
    terrainNoise = terrainNoise + altitude;
    
    let rivers = mapRangeSmooth(terrainNoise, -(1-args.lakes), -(1-args.lakes) + args.lakesFalloff, 3, 0) * .2;

    terrainNoise = MathUtils.lerp(
      terrainNoise * terrainNoise,
      terrainNoise * terrainNoise * terrainNoise,
      args.smoothLowerPlanes
    );

    return {y: MathUtils.lerp(terrainNoise, -3, MathUtils.clamp(rivers * args.rivers * 3, 0, 1)), water: rivers};
  };

  let fbmCanyons= new FbmNoiseBuilder()
  .octaves(args.octaves)
  .lacunarity(args.lacunarity)
  .gain(args.gain)
  .seed(args.seed)
  .offset(0.25)
  .amplitude(args.amplitude * 1.5)
  .frequency(args.frequency * 0.3)
  .build();


  const desertTerrain = (x: number, z: number) => {
    let terrainNoise = normalizeFbmRange(Math.abs(fbmCanyons(x + args.posX * 25, z + args.posZ * 25) - 0.25));
    const riverWidthVariation = normalizeFbmRange(fbmValiation(x + 1000 + args.posX * 25, z + 1000 + args.posZ * 25));
    const riversEdge1 = mapLinear(args.riverWidth, 0, 1, .2, .45) * mapLinear(riverWidthVariation, 0, 1, 0.75, 1.15);
    const riversEdge2 = mapLinear(args.riverWidth, 0, 1, .3, .55) * mapLinear(riverWidthVariation, 0, 1, 0.75, 1.15);
    const rivers = mapRangeSmooth(terrainNoise, riversEdge1, riversEdge2, 1, 0) * .2;
    const cliffs = mapRangeSmooth(terrainNoise, 0.5, .8, 0, 1);
    return {y: cliffs - rivers, water: rivers * 5};
  };

  displaceY(geometry, 
    (x: number, z: number) => {

      let biome = normalizeFbmRange(fbmBiomes(x + 500 + args.posX * 25, z + 500 + args.posZ * 25));
      biome = mapRangeSmooth(biome, 0.65, 0.8, 0, 1)
      if (closeTo(biome, 0, 0.004)) {
        const t = desertTerrain(x, z);
        return {y: t.y, biome: [biome, t.water, 0]};
      } 
      if (closeTo(biome, 1, 0.004)) {
        const t = defaultTerrain(x, z);
        return {y: t.y, biome: [biome, t.water, 0]};
      } 
       else {
        const tDesert = desertTerrain(x, z);
        const tDefault = defaultTerrain(x, z)
        const y = MathUtils.lerp(tDesert.y, tDefault.y, biome);
        const water = MathUtils.lerp(tDesert.water, tDefault.water, biome);
        return {y, biome: [biome, water, 0]}
      }
      
    }, 2.8 * (1 - args.smoothLowerPlanes * 0.5));

  return geometry;
}

=== src/types/index.ts ===
/**
 * Camera configuration for flight controls
 */
export interface CameraConfig {
  fov: number;
  near: number;
  far: number;
  baseSpeed: number;
  minSpeed: number;
  maxSpeed: number;
  acceleration: number;
  mouseSensitivity: number;
  /** Minimum altitude above ground level (meters) */
  minAltitudeAGL: number;
  /** Altitude below which speed starts reducing (meters) */
  slowdownAltitude: number;
  /** Speed multiplier at minimum altitude (0.0 to 1.0) */
  slowdownFactor: number;
}

=== src/ui/ShaderUIController.ts ===
import { GUI } from 'lil-gui';
import { MoonMaterial, type MoonMaterialParams } from '../shaders/MoonMaterial';
import { CelestialSystem } from '../environment/CelestialSystem';

/**
 * UI Controller for MoonMaterial shader parameters and lighting
 * Provides organized GUI controls using lil-gui
 */
export class ShaderUIController {
  private gui: GUI;
  private material: MoonMaterial;
  private params: MoonMaterialParams;
  private celestialSystem: CelestialSystem | null = null;

  constructor(material: MoonMaterial, celestialSystem?: CelestialSystem) {
    this.material = material;
    this.celestialSystem = celestialSystem ?? null;
    // Get initial params - we'll use onChange handlers instead of Proxy
    this.params = material.getParams();
    
    // Sync initial planetRadius to celestial system
    if (this.celestialSystem) {
      this.celestialSystem.setPlanetRadius(this.params.planetRadius);
    }
    
    // Create GUI instance
    this.gui = new GUI();
    this.gui.title('Lunar Surface Shader');
    this.gui.domElement.style.position = 'fixed';
    this.gui.domElement.style.top = '10px';
    this.gui.domElement.style.right = '10px';
    this.gui.domElement.style.zIndex = '1000';

    // Create organized folders
    this.setupTogglesFolder();
    this.setupNoiseFolder();
    this.setupCratersFolder();
    this.setupColorsFolder();
    this.setupCurvatureFolder();
    this.setupLightingFolder();
  }

  /**
   * Setup toggles folder
   */
  private setupTogglesFolder(): void {
    const folder = this.gui.addFolder('Toggles');
    
    folder.add(this.params, 'enableCraters')
      .name('Enable Craters')
      .onChange((value: boolean) => this.material.setParam('enableCraters', value));

    folder.add(this.params, 'enableNoise')
      .name('Enable Noise')
      .onChange((value: boolean) => this.material.setParam('enableNoise', value));

    folder.add(this.params, 'enableColorVariation')
      .name('Enable Color Variation')
      .onChange((value: boolean) => this.material.setParam('enableColorVariation', value));

    folder.open();
  }

  /**
   * Setup noise parameters folder
   */
  private setupNoiseFolder(): void {
    const folder = this.gui.addFolder('Noise');
    
    folder.add(this.params, 'noiseFrequency', 1.0, 20.0, 0.1)
      .name('Noise Frequency')
      .onChange((value: number) => this.material.setParam('noiseFrequency', value));

    folder.add(this.params, 'noiseAmplitude', 0.0, 0.2, 0.01)
      .name('Noise Amplitude')
      .onChange((value: number) => this.material.setParam('noiseAmplitude', value));

    folder.add(this.params, 'distortionFrequency', 0.1, 2.0, 0.1)
      .name('Distortion Frequency')
      .onChange((value: number) => this.material.setParam('distortionFrequency', value));
  }

  /**
   * Setup craters parameters folder
   */
  private setupCratersFolder(): void {
    const folder = this.gui.addFolder('Craters');
    
    folder.add(this.params, 'scale', 0.01, 0.2, 0.01)
      .name('Crater Density')
      .onChange((value: number) => this.material.setParam('scale', value));

    folder.add(this.params, 'distortion', 0.0, 1.0, 0.05)
      .name('Crater Wobble')
      .onChange((value: number) => this.material.setParam('distortion', value));

    const largeFolder = folder.addFolder('Large Craters');
    largeFolder.add(this.params, 'largeCraterScale', 0.1, 2.0, 0.1)
      .name('Scale Multiplier')
      .onChange((value: number) => this.material.setParam('largeCraterScale', value));
    largeFolder.add(this.params, 'largeCraterSmoothMin', 0.0, 0.5, 0.05)
      .name('Smoothstep Min')
      .onChange((value: number) => this.material.setParam('largeCraterSmoothMin', value));
    largeFolder.add(this.params, 'largeCraterSmoothMax', 0.5, 1.0, 0.05)
      .name('Smoothstep Max')
      .onChange((value: number) => this.material.setParam('largeCraterSmoothMax', value));
    largeFolder.add(this.params, 'largeCraterWeight', 0.0, 1.0, 0.1)
      .name('Blend Weight')
      .onChange((value: number) => this.material.setParam('largeCraterWeight', value));

    const mediumFolder = folder.addFolder('Medium Craters');
    mediumFolder.add(this.params, 'mediumCraterScale', 0.5, 3.0, 0.1)
      .name('Scale Multiplier')
      .onChange((value: number) => this.material.setParam('mediumCraterScale', value));
    mediumFolder.add(this.params, 'mediumCraterSmoothMin', 0.0, 0.5, 0.05)
      .name('Smoothstep Min')
      .onChange((value: number) => this.material.setParam('mediumCraterSmoothMin', value));
    mediumFolder.add(this.params, 'mediumCraterSmoothMax', 0.5, 1.0, 0.05)
      .name('Smoothstep Max')
      .onChange((value: number) => this.material.setParam('mediumCraterSmoothMax', value));
    mediumFolder.add(this.params, 'mediumCraterWeight', 0.0, 1.0, 0.1)
      .name('Blend Weight')
      .onChange((value: number) => this.material.setParam('mediumCraterWeight', value));
  }

  /**
   * Setup color parameters folder
   */
  private setupColorsFolder(): void {
    const folder = this.gui.addFolder('Colors');
    
    folder.add(this.params, 'colorVariationFrequency', 0.001, 0.02, 0.001)
      .name('Variation Frequency')
      .onChange((value: number) => this.material.setParam('colorVariationFrequency', value));

    folder.add(this.params, 'baseColorBlend', 0.0, 1.0, 0.1)
      .name('Base Color Blend')
      .onChange((value: number) => this.material.setParam('baseColorBlend', value));

    folder.add(this.params, 'brightnessBoost', 1.0, 5.0, 0.1)
      .name('Brightness Boost')
      .onChange((value: number) => this.material.setParam('brightnessBoost', value));
  }

  /**
   * Setup curvature parameters folder
   */
  private setupCurvatureFolder(): void {
    const folder = this.gui.addFolder('Curvature');
    
    folder.add(this.params, 'enableCurvature')
      .name('Enable Curvature')
      .onChange((value: boolean) => this.material.setParam('enableCurvature', value));

    folder.add(this.params, 'planetRadius', 1000, 50000, 500)
      .name('Planet Radius (m)')
      .onChange((value: number) => {
        // Update terrain shader
        this.material.setParam('planetRadius', value);
        // Sync to celestial system (sun, Earth, stars rotation)
        if (this.celestialSystem) {
          this.celestialSystem.setPlanetRadius(value);
        }
      });
    
    folder.open();
  }

  /**
   * Setup lighting parameters folder
   * Controls for sun, earthshine, and spaceship lights
   */
  private setupLightingFolder(): void {
    if (!this.celestialSystem) return;
    
    const folder = this.gui.addFolder('Lighting');
    
    // Create a proxy object for the lighting params since celestialSystem uses getters/setters
    const lightingParams = {
      sunIntensity: this.celestialSystem.sunIntensity,
      earthshineMultiplier: this.celestialSystem.earthshineMultiplier,
      spaceshipLightIntensity: this.celestialSystem.spaceshipLightIntensity,
      spaceshipLightRange: this.celestialSystem.spaceshipLightRange,
      flashlightIntensity: this.celestialSystem.flashlightIntensity,
      flashlightRange: this.celestialSystem.flashlightRange,
      flashlightAngle: this.celestialSystem.flashlightAngle * (180 / Math.PI), // Convert to degrees for UI
    };
    
    folder.add(lightingParams, 'sunIntensity', 0, 20, 0.1)
      .name('Sun Intensity')
      .onChange((value: number) => {
        if (this.celestialSystem) {
          this.celestialSystem.sunIntensity = value;
        }
      });
    
    folder.add(lightingParams, 'earthshineMultiplier', 0, 1, 0.01)
      .name('Earthshine Multiplier')
      .onChange((value: number) => {
        if (this.celestialSystem) {
          this.celestialSystem.earthshineMultiplier = value;
        }
      });
    
    folder.add(lightingParams, 'spaceshipLightIntensity', 0, 20, 1)
      .name('Spaceship Intensity')
      .onChange((value: number) => {
        if (this.celestialSystem) {
          this.celestialSystem.spaceshipLightIntensity = value;
        }
      });
    
    folder.add(lightingParams, 'spaceshipLightRange', 10, 500, 10)
      .name('Spaceship Range (m)')
      .onChange((value: number) => {
        if (this.celestialSystem) {
          this.celestialSystem.spaceshipLightRange = value;
        }
      });
    
    folder.add(lightingParams, 'flashlightIntensity', 0, 50, 1)
      .name('Flashlight Intensity')
      .onChange((value: number) => {
        if (this.celestialSystem) {
          this.celestialSystem.flashlightIntensity = value;
        }
      });
    
    folder.add(lightingParams, 'flashlightRange', 50, 1000, 50)
      .name('Flashlight Range (m)')
      .onChange((value: number) => {
        if (this.celestialSystem) {
          this.celestialSystem.flashlightRange = value;
        }
      });
    
    folder.add(lightingParams, 'flashlightAngle', 5, 60, 1)
      .name('Flashlight Angle (°)')
      .onChange((value: number) => {
        if (this.celestialSystem) {
          // Convert degrees back to radians
          this.celestialSystem.flashlightAngle = value * (Math.PI / 180);
        }
      });
    
    folder.open();
  }

  /**
   * Dispose of the GUI
   */
  dispose(): void {
    this.gui.destroy();
  }
}

=== src/utils/math.ts ===
/**
 * Math utilities for vector operations and calculations
 */

/**
 * Clamp value between min and max
 */
export function clamp(value: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, value));
}

/**
 * Linear interpolation
 */
export function lerp(a: number, b: number, t: number): number {
  return a + (b - a) * t;
}

/**
 * Smooth step interpolation
 */
export function smoothstep(edge0: number, edge1: number, x: number): number {
  const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
  return t * t * (3 - 2 * t);
}

/**
 * Convert degrees to radians
 */
export function degToRad(degrees: number): number {
  return degrees * (Math.PI / 180);
}

/**
 * Convert radians to degrees
 */
export function radToDeg(radians: number): number {
  return radians * (180 / Math.PI);
}

/**
 * Calculate distance between two 2D points
 */
export function distance2D(x1: number, z1: number, x2: number, z2: number): number {
  const dx = x2 - x1;
  const dz = z2 - z1;
  return Math.sqrt(dx * dx + dz * dz);
}

